# 알고리즘



### 1. stable sort와 unstable sort가 무엇인지 예시와 함께 설명하고, 어떤 알고리즘들이 있는지 분류해주세요.

- stable sort는 sorting 작업을 진행한 전과 후에, 같은 분류 기준을 가진 node들의 순서가 변하지 않는 것을 말합니다. 예를 들어 13, 36, 24, 10, 14 과 같이 두자리 자연수 5개가 있을 때, 10의 자리 기준 오름 차순으로 정렬한다고 했을때, 13, 10, 14, 24, 36 처럼 13, 10, 14 순서가 유지된다면 stable sort이고, 10, 14, 13, 24, 36 처럼 순서가 유지되지 않으면 unstable sort라고 합니다. stable sort의 종류에는 bubble sort, insertion sort, Merge Sort 가 있고, Unstable Sort의 종류에는 Selection Sort, Heap Sort, Quick Sort 등이 있습니다.





### 2. Fibonacci에서의 재귀, 동적프로그래밍, 반복의 세 가지 방식에 대한 시간복잡도와 공간복잡도

```python
# 재귀
def fibonacci_re(n):
		if n < 2:
				return n
		return fibo(n-1) + fibo(n-2) # recursion 한개가 2개의 연산을 불러 일으킨다. 
# n번째 피보나치연산은 depth가 n인 트리의 노드 수 만큼 연산이 일어나므로 2^N 
																	
# 시간복잡도: O(2^N)
# 공간복잡도: recursion마다 스택에 1개씩 쌓이므로 길이 n의 스택이 필요 : O(N) (?)


# DP
def fibonacci_dp(n):
		dp = []
		dp.append(0)
		dp.append(1)
		for i in range(n-1):  # n번 반복
				dp.append(dp[-1] + dp[-2])  # 길이가 n인 dp배열에서 index로 조회 및 덧셈: O(1)
		return dp[n]

# 시간복잡도: O(N)
# 공간복잡도: 길이가 n인 배열을 사용하므로 O(N)


# 반복
def fibonacci_loop(n):
		a, b = 0, 1
		for i in range(n-1): 
				a, b = b, a+b     # 덧셈과 할당을 n번 반복하므로 O(N)
		return b

# 시간복잡도: O(N)
# 공간복잡도: 변수 두개만 사용하므로 O(1)
```





### 3. Quick sort가 일어나는 과정을 설명해주세요.

- Quick Sort는 분할 정복 방법(Divide and Conquer)을 통해서 배열을 정렬합니다.
- 분할 정렬은 분할, 정복, 결합이 일어나면서 정렬이 이루어집니다.
  - 분할: 정해진 pivot을 기준을 작은 원소와 큰 원소, 두 배열로 원본 배열을 분할합니다.
  - 정복: 부분 배열을 정렬합니다. 모든 부분 배열이 길이가 1이 되지 않으면, 분할과 정복을 recursion을 통해서 반복합니다.
  - 결합: 최종적으로 길이가 1이 된 배열들을 합칩니다.
- 퀵소트는 좌측엔 pivot보다 작은 원소, 우측엔 pivot보다 큰 원소로 이루어진 배열로 분할 할 것이기 때문에, 배열에서 가장 좌측에서 시작하는 index와 우측에서 시작하는 index가 서로에게 다가오며, 자신의 방향의 배열과 맞지 않은 원소를 탐색합니다. 찾았다면 두 인덱스에 있는 값을 교환합니다. 이 과정을 반복하다 보면 언젠가 두 인덱스가 교차하게 되는데, 그 때 한번의 분할 정복이 끝나게 됩니다.
- 갈라진 두 배열을 각가 다시 quick sort에 넣고 반환값을 합쳐서 최종 결과물이 나오는데, 이 quick sort에 들어간 배열은 그 안에서 또다시 분할 정복이 이루어지게 되고, 길이가 1인 배열은 그대로 리턴되면서 병합의 과정을 거칩니다.
- O(NlogN)의 시간복잡도를 가집니다.





### 4. **Merge sort의 장단점과 일어나는 과정을 설명해주세요.**

- Merge Sort는 분할 정복 방법을 통해서 배열을 정렬합니다.
  - 분할: 배열의 길이가 1이 될 때 까지 배열을 두개로 분할합니다.
  - 정복: 부분 배열을 정렬합니다. Merge Sort의 경우 배열의 길이가 1이  될때까지는 정렬이 이루어지지 않습니다.
  - 결합: 정렬된 부분 배열을 하나의 배열에 합칩니다.
- Merge Sort의 결합과정은 두 부분배열이 정렬되었다는 가정하에 진행되며,  두 부분배열의 앞 index의 원소부터 서로 비교하며 작은 원소를 합병 될 리스트에 차례로 집어 넣습니다. 한쪽 리스트가 동나면 나머지 리스트의 원소를 그대로 뒤에 추가합니다. 이렇게 하나의 원소로 이루어진 부분배열로 모두 쪼개졌다가 결합 과정을 거쳐서 정렬된 배열로 재탄생합니다.
- 반으로 나누는 과정을 거치므로, 최악의 경우에도 O(NlogN)의 시간복잡도를 보장합니다. 하지만 길이가 n인 리스트를 정렬하기 위해서 길이가 n인 임시 배열이 하나 더 필요하므로 공간 더 소요됩니다.



### 5. Greedy 알고리즘에 대해 설명하고, 단점과 사용하는 상황을 설명해주세요. 

- Greedy 알고리즘(탐욕 알고리즘)은 해당 선택 이후 변화를 생각하지 않고, 그 순간 가장 최선화된 선택을 해 나가는 알고리즘을 말합니다. 당장 최선화된 선택을 하기 때문에 전체적으로 봤을 때는 최적의 답을 주지 못하는 경우가 있습니다. 
  - 예를 들어서 100원, 80원, 40원, 10원짜리 동전으로 120원을 거슬러주는 상황이 있습니다. Greedy알고리즘을 쓰면 100원을 먼저 주는게 최선이기에 100원짜리 한개를 사용하고 남은 20원을 10원 두개로 해결해서 총 3개의 동전을 씁니다. 하지만, 진짜 최선해는 80, 40원 두개 만으로 해결할 수 있습니다.
- 따라서 Greedy 알고리즘은 Greedy 알고리즘을 사용해도, 즉 모든 상황에서 그 상황에서의 최선값을 찾아나가는 것이 최선 해를 찾는 방법임이 보장되는 경우에만 사용해야 합니다. 또한 최선해를 찾는 방법이 아닌, 혹은 최선해를 찾는 방법이 어려운 경우 대안으로 최적해를 찾아야하는 문제에서는 사용할 수 있습니다.eㅁ





### 6. Heap에 대해 설명하고 삽입, 삭제 과정을 설명해주세요.

- 힙은 특별한 조건을 만족하는 완전 이진 트리를 말합니다.
  - 완전 이진 트리는 모든 노드에 자식이 2개 이하이면서 노드는 위에서부터, 왼쪽에서부터 채워지는 규칙을 가진 트리입니다.
- 최대 힙과 최소 힙 크게 두가지가 있는데, 노드간의 관계에서 최소힙은 항상 parent가 child보다 작아야하고, 최대힙은 항상 parent가 child보다 커야합니다.
- 삽입 연산의 경우, 먼저 완전 이진트리를 만족시키는 위치(최 하단, 가장 좌측)에 leaf node로 삽입합니다. 그 후 최대 힙, 혹은 최소 힙을 만족할 때 까지 부모 노드와 교환하는 형식을 통해 자기 자리로 이동합니다.
- 삭제 연산의 경우, 먼저 삭제 할 node에 데이터를 지우고, 그 자리에 node가 삭제되어도 완전 이진 트리를 유지하는 node의 데이터, 즉 가장 우측 leaf node의 데이터를 넣고, 해당 leaf node를 삭제합니다. 마찬가지로 최대힙 혹은 최소 힙을 만족할 때 까지 교환을 합니다.
- 완전 이진 트리로 구성되어 있는 힙 트리를, 배열에 담아 저장하고, 그 배열을 통해서 빠르게 최대, 최소값을 찾아낼 수 있으며, 시간 복잡도는 O(NlogN) 이 됩니다.





### 7. Python의 내장함수 sort에 사용된 정렬 방식을 설명해주세요.

- Python 의 내장함수 sort()는 Tim Sort라는 정렬방식을 사용합니다.
- merge sort는 최악의 경우에도 O(NlogN)의 시간복잡도를 만족하면서 참조 지역성의 원리를 어느정도 만족하기 때문에, NlogN에 붙는 상수값 C (빅 O 노테이션에서는 무시되지만 같은 NlogN 알고리즘 끼리 비교할 때는 유의미한 값이다)가 비교적 작다. 하지만 merge sort는 최선의 경우에도 O(NlogN)입니다. 
- merge sort의 장점을 가져가면서 최선의 경우 시간복잡도를 줄이기 위해 insertion sort와 결합한 것이 tim sort입니다. insertion sort는 인접한 메모리와 비교하기 때문에 역시 참조 지역성의 원리를 잘 만족하면서, 원소가 들어갈 위치를 찾는 알고리즘을 이분 탐색을 이용하는 binary insertion sort를 이용함으로써 소요시간이 더 줄어든다. binary insertion sort를 최적화해서 이용하기 위해 2^x 크기로 분할합니다.
- 이렇게 진행되는 Tim sort는 최악의 시간복잡도가 O(nlogn)이면서 안정적이기 때문에 많은 언어에서 표준 정렬 알고리즘으로 채택되어 사용되고 있습니다.





### 8. LRU 페이지 교체 알고리즘을 코드로 구현해주세요.

- LRU 페이지 교체 알고리즘은 Least Recently Use, 즉 가장 마지막으로 사용된 페이지를 교체하는 알고리즘입니다. 캐시메모리를 사용하는 경우 자주 사용하는 데이터를 페이지 단위로 캐시메모리에 로드하여 빠르게 찾아와서 쓰게 되는데, 캐시 메모리는 메인메모리보다 작기 때문에, 언젠가 꽉차고 새로운 페이지를 담기 위해서 교체를 해주어야 합니다. 최근에 사용된 순서대로 array에 담으면서 LRU를 구현할 수 있습니다.

```python
data_list = [3, 5, 1, 3, 4, 2, 4, 5, 6, 2, 3] # 여기서 data는 페이지 번호
cache = []
cache_size = 5

for data in data_list:
	# data가 캐시에 있다면 꽉찼더라도 뺏다가 뒤에 넣으면 1자리가 비므로 그냥 빼서 넣습니다.
	if data in cache:
		cache.append(cache.pop(cache.index(data)))
	else:
		# 캐시에 없는데 아직 공간이 있으면 그냥 넣습니다.
		if cache_size > len(cache):
			cache.append(data)
		# 공간이 없으면 LRU에 따라 맨 앞의 페이지를 지우고 넣습니다.
		else:
			cache.pop(0)
			cache.append(data)
```





### 9. Bellman-Ford 알고리즘에 대해 설명해주세요.

- 벨만 포드 알고리즘은 최단 경로 알고리즘 중 다익스트라 알고리즘의 단점을 보완하기 위한 알고리즘입니다.
  - 다익스트라 알고리즘은 길찾는 과정, 음수 크기의 간선이 존재하는 경우, 음수 cycle이 생길 수 있고, 영원히 도착점에 도달하지 못하여 거리가 무한대가 된다는 단점이 있었습니다.
- 벨만 포드 알고리즘은 n개의 노드가 잇을 때, n-1개의 탐색으로 최단거리가 무조건 나온다는 가정 하에 진행합니다. 시작 노드에서 한번 갔을 때의 모든 최소값을 저장하고, Dynamic Programming의 방식으로 2, 3, ... , n-1 번째 탐색 시 비용의 최소값을 계속 갱신합니다. 이 때 더 짧은 비용으로 탐색할 수 있으면 갱신해주는 것을 Relax라고 합니다.
- 다익스트라 알고리즘은 음수의 간선이 있으면 적용이 불가능하다는 단점이 있지만, N개의 노드에서  O(N^2)의 속도로 탐색을 할 수 있습니다. 하지만 벨만 포드 알고리즘은 N-1번의 단계를 진행하며, 모든 node끼리 간선이 연결되어있다는 가정하에, 매 단계마다 N개의 노드가 N-1개의 간선을 탐색해야하므로 O(N^3)으로 느립니다. 따라서 음수 간선이 없는 경우 다익스트라 알고리즘을 사용하는 것이 좋습니다.