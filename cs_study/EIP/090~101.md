# CS_Study_정보처리기사 4주차

> 04.21 ~ 04.27
>
> 제 3과목 데이터베이스 구축 - 2) 물리 데이터베이스 설계
>
> 90장~101장
>
> by. 김승현



## 90. 사전 조사 분석



### 물리 데이터베이스 설계

- 논리적 데이터베이스를 물리적 저장장치에 저장할 수 있는 물리적 구조의 데이터로 변환하는 과정이다.
- 기본적인 데이터 단위는 저장 레코드(stored Record)
- 저장 레코드의 양식 설계, 레코드 집중(Record Clustering)의 분석 및 설계, 접근 경로 설계 등이 필수
- 설계시 고려사항
  - 인덱스 구조
  - 레코드 크기
  - 파일에 존재하는 레코드 개수
  - 파일에 대한 트랜잭션의 갱신과 참조 성향
  - 성능 향상을 위한 개념 스키마의 변경 여부 검토
  - 빈번한 질의와 트랜잭션들의 수행속도를 높이기 위한 고려
  - 시스템 운용 시 파일 크기의 변화 가능성

- 물리적 설계 옵션
  - 반응시간
  - 공간 활용도
  - 트랜잭션 처리량



### 데이터 명명 규칙 파악

- 정해진 것은 아니지만, 각 조직 별로 효율적인 모델 설계를 위해서 데이터베이스에 사용 될 레코드의 값의 규칙을 설정한다.
- 중복 구축 등을 방지할 수 있으며, 도메인과 데이터 사전에 대한 지식이 필요하다
- 도메인을 통해 데이터 타입, 크기 등을 표준화 규칙에 따라 일관적으로 정의할 수 있다





### 시스템 자원 파악

- 데이터가 저장될 물리적 저장 공간에 대한 정보를 파악하는 것도 중요하다
- CPU의 성능, 메모리의 크기, 디스크의 크기, 입/출력 컨트롤러의 성능, 네트워크 속도등을 고려한다.
- 운영체제 및 DBMS 버전의 파악도 필요하다.



### 데이터베이스 관리 요소 파악

- 데이어 베이스 운영과 관련된 관리요소로써 데이터베이스 시스템의 환경에 따라 달라질 수 있다.
- 데이터베이스의 구조, 이중화 구성, 분산 데이터베이스, 접근 제어/접근통제, DB암호화 등 카테고리로 파악할 수 있다.



### 기출문제 따라잡기

1. 데이터베이스 설계 시 물리적 설계단계에서 수행하는 사항이 아닌 것은?

   목표 DBMS에 맞는 스키마 설계는 논리적 설계 단계에서 수행한다

2. 물리적 데이터베이스 설계 수행 시 결정 사항으로 거리가 먼 것은?

   개념스키마 설계와 외부 스키마 설계는 다른 단계에서 수행된다.

3. 데이터 명명 규칙에 대한 설명으로 틀린 것은?

   데이터베이스 설계의 명명규칙은 일관적이어야한다.





## 91. 데이터베이스 저장 공간 설계





### 테이블

- 데이터베이스의 가장 기본적인 객체로 row와 column으로 구성되어있다.

- 테이블은 논리 설계 단계의 개체(Entity)에 대응하는 객체이다.

- DBMS의 종류에 따라 테이블의 명칭과 기능은 약간 차이가 있다.

- 테이블의 종류

  - 일반테이블: 대부분의 DBMS의 표준테이블

    row위치는 속성값과 상관 없이 데이터가 저장되는 순서에 따라 결정된다.

  - 클러스터드 인덱스 테이블: 기본키나 인덱스키의 순서에 따라 데이터가 저장된다.

    정렬이 되어있기 때문에 일반 테이블에 비해 접근 경로가 단축된다.

  - 파티셔닝 테이블: 대용량의 테이블을 작은 논리적 단위인 파티션으로 나눈 테이블이다.

    대용량 데이터를 나눔으로써 효과적 관리가 가능하지만, 분할을 잘못하면 성능 저하 등 역효과를 초래할 수도 있다.

    파티셔닝 방법에 따라 범위 분할, 해시 분할, 조합 분할 등으로 나뉜다.

  - 외부 테이블: 일반 테이블처럼 이용할 수 있는 외부 파일로, 데이터베이스 내에 객체처럼 존재한다.

    데이터웨어하우스에서 ETL등의 작업에 유용하게 사용된다.

  - 임시 테이블: 트랜잭션이나 세션별로 데이터를 저장하고 처리할 수 있는 테이블

    임시테이블에 저장된 데이터는 트랜잭션이 종료되면 삭제된다.

  - 컬럼: 테이블의 열을 구성하는 요소로 데이터 타입, 길이 등으로 정의된다.

    데이터 타입은 일관성 유지를 위해 가장 기본적으로 사용되며, 도메인을 정의한 경우 타입과 길이가 결정된다.

    참조 관계인 컬럼들은 데이터 타입과 길이가 일치해야 한다.

    데이터 타입과 길이 지정 시 고려 사항

    - 가변길이 데이터 타입: 예상되는 최대 길이로 정의
    - 고정 길이 데이터 타입: 최소 길이로 지정
    - 소수점 이하 자리수 : 반올림되어 저장

    데이터 타입에 따른 컬럼의 물리적인 순서

    - 고정 길이 칼럼, NOT Null: 앞쪽
    - 가변 길이 컬럼: 뒤쪽
    - Null이 많을 것 같은 컬럼: 뒤쪽

  - 테이블 스페이스: 테이블이 저장되는 논리적인 영역으로, 하나의 테이블 스페이스에 하나 이상의 테이블을 저장할 수 있다.

    테이블이 저장되는 물리적 영역은 데이터 파일이라고 한다.

    테이블, 테이블 스페이스, 데이터 파일로 나눠 관리하면서 논리적 구성이 물리적 구성에 종속되지 않아 투명성이 보장된다.

    저장되는 내용에 따라 테이블, 인덱스, 임시 등의 용도로 구분하여 설계한다.

    고려사항

    - 테이블스페이스는 업무별로 구분하여 지정한다.
    - 대용량 테이블은 하나의 테이블스페이스에 독립적으로 저장한다
    - 테이블과 인덱스는 분리하여 저장한다
    - LOB(Large Object) 타입의 데이터는 독립적인 공간으로 지정한다.





### 기출문제 따라잡기

1. 데이터베이스의 모든 데이터가 저장되는 테이블에 대한 설명으로 틀린 것은?

   테이블은 논리 데이터 모델의 개체에 대응하는 객체이다

2. 다응ㅁ 중 테이블에 대한 설명으로 가장 옳지 않은 것은?

   외부 테이블은 외부 파일을 데이터베이스 내의 테이블처럼 활용하는 것이다

3. 다음 중 컬럼에 대한 설명으로 잘못된 것은?

   데이터 타입과 길이가 다른 컬럼 값을 비교할땐 DBMS에서 자체적으로 데이터타입을 변환한 후 비교한다.

4. 다음 중 테이블 스페이스에 대한 설명으로 틀린 것은?

   테이블 스페이스는 테이블이 저장되는 논리적인 영역이며, 물리적인 영역은 데이터 파일이다.





## 92. 트랜잭션 분석 / CRUD 분석



### 트랜잭션

- 트랜잭션은 데이터베이스 상태를 변환시키는 논리적 기능을 수행하기 위한 작업의 단위, 혹은 일련의 연산을 의미한다.
- 데이터베이스 시스템에서 병행제어 및 회복 작업 시 처리되는 작업의 논리적 단위로 사용된다.
- 사용자가 시스템에 대한 서비스 요구 시 시스템이 응답하기 위한 상태 변환 과정의 작업 단위로 사용된다.

- 트랜잭션의 특성
  - 원자성(Atomicity): 트랜잭션의 연산은 데이터베이스에 모두 반영되도록 완료 되던지 복구되어야한다. 따라서 하나라도 오류가 나면 트랜잭션 전부가 취소되어야 한다
  - 일관성(Consistency): 트랜잭션이 성공적으로 완료되면 언제나 일관성있는 데이터베이스 상태가 된다.
  - 독립성(Isolation): 둘 이상의 트랜잭션이 동시에 실행되는 경우, 서로의 연산에 끼어들 수 없으며, 따라서 다른 트랜잭션에서 수행 결과를 참조할 수 없다
  - 영속성(Durability): 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나도 영구적으로 반영되어야 한다



### CRUD 분석

- CRUD는 Create, Read, Update, Delete를 마한다.
- CRUD분석으로 트랜잭션의 주기별 발생 횟수를 파악하고 연관된 테이블들을 분석하면 테이블에 저장되는 데이터의 양을 유추할 수 있다.



### CRUD 매트릭스

- 2차원 형태의 표에, 행에는 프로세스, 열에는 테이블, 행과 열이 만나는 위치에는 해당 프로세스가 테이블에 발생시키는 변화를 C,R,U,D로 표현하는 것이다.
- 복수의 변화가 생길 때는 C > D > U > R 의 우선순위를 적용하여 한가지만 적지만, 목적에 따라 모두 기록할 수 있다.

- 각 행과 각열에 누락된 테이블이 없어야하며, 확인을 통해 불필요한 프로세스를 찾을 수 잇다.



### 트랜잭션 분석

- CRUD 매트릭스를 기반으로 테이블에 발생하는 트랜잭션 양을 분석하여 테이블에 저장되는 데이터의 양을 유추하고, 그를 근거로 DB 용량을 산정하고 DB 구조를 최적화시키는 것이다.
- 프로세스가 과도하게 접근하는 테이블을 확인하여 여러 디스크에 배치함으로써 디스크 입.출력 분산을 통한 성능 향상을 가져올 수 있다

- 트랜잭션 분석서를 작성하여 분석을 할 수 있다.
- 단위 프로세스, CRUD연산, 테이블명, 컬럼명, 테이블 참조횟수, 트랜잭션 수, 발생 주기 등으로 트랜잭션을 분석하면서 주로 쓰이는 것, 특징 등을 분석할 수 있다.





### 기출문제 따라잡기

1. 다음 설명과 관련 있는 트랜잭션의 특징은?

   연산이 모두 실행되거나 실행되지 않아야 함은 Atomicity와 관련 있다

2. commit과 Rollback 명령어에 의해 보장받는 트랜잭션의 특성은?

   Atomicity는 Commit과 Rollback이 한번에 전부 적용되어야 한다는 특성이다

3. 데이터베이스에 영향을 주는 생성, 읽기, 갱신, 삭제 연산으로 프로세스와 테이블 간에 매트릭스를 만들어서 트랜잭션을 분석하는 것은?

   CRUD 분석이라고 한다

4. CRUD 분석에 대한 설명으로 옳지 않은 것은?

   우선순위는 C, D, U, R 순서이다.

5. CRUD 매트릭스에서 검토사항이 아닌 것은?

   프로세스에 C또는 R이 없을 수도 있다. 그 테이블의 다른 프로세스가 가지고 있으면 되기 때문이다.



## 93. 인덱스 설계



### 인덱스

- 레코드를 빠르게 접근하기 위해 <키 값, 포인터> 쌍으로 구성되는 데이터 구조이다.
- 물리적 구조와 밀접한 관계가 있으며, 접근하는 방법을 제공한다.
- 인덱스를 통해 레코드에 대한 엑세스를 빠르게 수행할 수 있다.
- 삽입과 삭제가 수시로 일어나는 경우 인덱스의 갯수를 최소화하는게 효율적이다.
- 인덱스가 없으면, 모든 데이터 페이지를 확인하는 테이블 스캔이 발생한다.
- 기본 키를 위한 인덱스를 기본 인덱스라고 하고 나머지 인덱스를 보조 인덱스라고 한다.
- 레코드의 물리적 순서가 인덱스의 엔트리 순서와 일치하게 유지하는 것을 클러스터드 인덱스라고 한다.



### 트리 기반 인덱스

- 인덱스를 구성하는 블록들이 트리구조를 이루고 있는 것으로, DBMS에서 보통 트리구조 기반의 B+ 트리 인덱스를 주로 활용한다.

  - B 트리 인덱스: 루트 노드에서 하위 노드로 키 값의 크기를 비교해 나가면서 단말 노드에서 찾고자 하는 데이터를 검색한다.

    모든 리프노드는 같은 레벨에 있으며, 키 값과 레코드를 가리키는 포인터가 트리 노드에 오름차순으로 저장된다.

  - B+ 트리 인덱스: 단말 노드가 아닌 노드로 구성된 인덱스 세트와 단말 노드로만 구성된 순차 세트로 구분한다.

    인덱스 세트는 키 값을 찾아가는 경로로만 사용하며, 단말 노드는 해당 데이터 레코드의 주소를 가리킨다.

    인덱스 세트의 모든 키 값이 단말 노드에 다시 나타나므로 단말 노드만을 이용한 순차 처리가 가능하다



### 비트맵 인덱스

- 인덱스 칼럼의 데이터를 0, 1로 변환하여 인덱스 키로 사용한다.
- 분포도가 좋은 칼럼에 적합하며,효율적인 논리 연산이 가능하고, 저장 공간이 작다
- 다중 조건을 만족하는 튜플의 개수 계산에 적합하다
- 동일한 값의 반복으로 압축 효율이 좋다





### 함수 기반 인덱스

- 컬럼의 값 대신 컬럼에 특정 함수나 수식을 적용하여 산출된 값을 사용하며, B+트리 인덱스 혹은 비트맵 인덱스를 생성하여 사용한다
- 데이터를 입력하거나 수정할 때 함수를 적용해야 하므로 부하가 발생할 수 있다.
- 사용된 함수가 사용자 정의 함수이면 부하가 더 크다
- 대소문자, 띄어쓰기 등에 상관없이 조회할 때 유용하게 사용한다
- 적용 가능한 함수는 산술식, 사용자 정의함수, SQL Function, PAckage 등이 있다





### 비트맵 조인 인덱스

- 다수의 조인된 객체로 구성된 인덱스이며, 일반적 인덱스와 액세스 방법이 다르지만 물리적 구조는 비트맵 인덱스와 동일하다





### 도메인 인덱스

- 개발자가 필요한 인덱스를 직접 만들어 사용하는 것으로, 확장형 인덱스라고도 한다
- 개발자가 필요에 의해 만들었지만 프로그램에서 제공하는 인덱스처럼 사용할 수도 있다.



### 인덱스 설계

- 분명하게 드러난 컬럼에 대해 기본적인 인덱스를 먼저 지정한 후 개발 단계에서 필요한 인덱스의 설계를 반복적으로 진행한다.
- 설계 순서
  1. 인덱스의 대상 테이블이나 컬럼을 선정한다
     - 인덱스 대상 테이블 선정 기준: MULTI BLOCK READ 수, 랜덤 액세스 빈도, 특정 범위나 순서로 데이터 조회가 필요한지 여부, 다른 테이블과 순차적 조인이 발생하는지 여부
     - 인덱스 대상 칼럼 선정 기준: 분포도가 10~15프로 이내인 컬럼, 부분 처리 목적 여부, 입.출력 장표 등에서 조회 및 출력 조건으로 사용되는지 여부, 인덱스가 자동 생성되는 기본키와 Unique키 제약 조건을 사용한 컬럼, ORDER BY, GROUP BY, UNION 사용이 빈번한 컬럼 등
  2. 효율성을 검토하여 인덱스 최적화를 수행한다
  3. 인덱스 정의서를 작성한다

- 고려사항
  - 새로 추가되는 인덱스는 기존 액세스 경로에 영향을 미칠 수 있다
  - 인덱스를 많이 만든다고 좋은 것은 아니다. 오버헤드 발생
  - 넓은 범위를 처리하면 많은 오버헤드가 발생한다
  - 인덱스를 만들면 추가 저장 공간이 필요하다
  - 인덱스와 테이블 데이터의 저장 공간이 분리되도록 설계한다





### 기출문제 따라잡기

1. 인덱스에 대한 설명으로 부적절한 것은?

   삽입과 삭제가 수시로 일어나는 경우 인덱스의 개수를 최소화한다

2. 다음 중 함수 기반 인덱스에 대한 설명으로 옳지 않은 것은?

   사용자 정의 함수를 사용할 때 더 많은 부하가 발생한다

3. 인덱스에 대한 설명으로 틀린 것은?

   인덱스 설계는 기본적인 것만 진행한 후 개발단계에서 지속적으로 필요한 설계를 추가한다.



## 94. 뷰 설계



### 뷰의 개요

- 사용자에게 접근이 허용된 자료만 제한적으로 보여주기 위해 하나 이상의 기본 테이블로부터 유도된 이름을 가지는 가상 테이블이다.
- 저장 장치내에 물리적으로 존재하진 않지만 사용자에게는 있는 것처럼 간주된다.
- 데이터 보정, 처리 등 임시적인 작업을 위한 용도로 활용한다.

- 뷰는 기본 테이블과 같은 형태의 구조를 사용하며, 조작도 거의 같다
- 물리적으로 구현되어있지 않다
- 데이터의 논리적 독립성을 제공할 수 있다.
- 관리가 용이하고, 명령문이 간단해진다.
- 기본 테이블의 기본키를 포함한 속성 집합으로 뷰를 구성해야만 C, D, U 연산이 가능하다.
- 다른 뷰를 또 만들 때 기초가 될 수 있다.
- 뷰를 정의할때는 CREATE, 제거할때는 DROP을 사용한다.



### 뷰의 단점

- 독립적인 인덱스를 가질 수 없다
- 뷰의 정의를 변경할 수 없다
- 뷰에 구성된 내용은 삽입, 삭제, 갱신에 제약이 따른다





### 뷰의 설계

1. 대상 테이블 선정
2. 대상 컬럼 선정
3. 정의서 작성

- 고려사항

  - 테이블 구조가 단순화 될 수 있도록 반복적으로 조인을 설정하여 사용하거나 동일한 조건절을 사용하는 테이블을 뷰로 생성한다.
  - 동일한 테이블이라도 업무에 따라 테이블을 이용하는 부분이 달라질 수도 있으므로 사용할 데이터를 다양한 관점에서 제시해야 한다.

  - 데이터의 보안 유지를 고려하여 설계한다.



### 기출문제 따라잡기

1. 뷰에 대한 설명으로 옳지 않은 것은?

   저장장치내에는 물리적으로 구성되어있지 않다

2. 뷰에 대한 설명으로 틀린 것은?

   뷰의 정의는 변경할 수 없다

3. 뷰의 장점이 아닌 것은?

   뷰는 독립적인 인덱스를 가질 수 없다





## 95. 클러스터 설계



### 클러스터

- 데이터 저장 시 데이터 액세스 효율을 향상시키기 위해 동일한 성격의 데이터를 동일한 데이터 블록에 저장하는 물리적 저장 방법이다.
- 클러스터링 키로 지정된 컬럼 값의 순서대로 저장되고, 여러개의 테이블이 하나의 클러스터에 저장된다.
- 데이터 조회 속도가 늘어나지만, 데이터 입력, 수정, 삭제가 복잡해진다
- 데이터 분포도가 넓을 수록 유리하다.
- 저장 공간을 절약할 수 있다.
- 대용량을 처리하는 트랜잭션은 전체 테이블을 스캔하는 일이 자주 발생하므로 클러스터링을 하지 않는 것이 좋다.

- 처리 범위가 넓은 경우 단일 테이블 클러스터링을, 조인이 많이 발생하는 경우에는 다중 테이블 클러스터링을 사용한다
- 파티셔닝 된 테이블엔 클러스터링을 할 수 없다.
- 클러스터링 된 테이블에 클러스터드 인덱스를 생성하면 접근 성능이 향상된다.
- 클러스터 대상 테이블
  - 분포도가 넓은 테이블
  - 대량의 범위를 자주 조회하는 테이블
  - 입력, 수정, 삭제가 자주 발생하지 않는 테이블
  - 자주 조인되어 사용되는 테이블
  - ORDER BY, GROUP BY, UNION이 빈번한 테이블



### 기출문제 따라잡기

1. 다음 중 데이터베이스 테이블에서의 클러스터에 대한 설명으로 가장 옳지 않은 것은?

   클러스터는 데이터 입력, 수정, 삭제에는 성능 약화를 가져온다.

2. 다음중 클러스터링을 사용하기 적당하지 않은 테이블은?

   분포도가 넓은 테이블에 클러스터링을 자주 사용한다.





## 96. 파티션 설계



### 파티션

- 대용량의 데이블이나 인덱스를 작은 논리적 단위인 파티션으로 나누어 관리하는 것
- 성능 저하를 방지하면서 데이터 관리를 쉽게 할 수 있다.
- 테이블이나 인덱스를 파티셔닝하면 파티션 키 또는 인덱스키에 따라 물리적으로 별도의 공간에 데이터가 저장된다.
- 데이터 처리는 테이블 단위로 이뤄지고, 데이터 저장은 파티션별로 수행된다.

- 장단점

  - 장점

    쿼리 성능 향상, 디스크 성능 향상, 속도 빠름, 데이터 손상 정도 최소화, 데이터 가용성 햐야상, 파티션 단위 입출력 분산 가능

  - 단점

    세심한 관리 요구, 조인 비용 증가, 용량이 작은 테이블에 파티셔닝은 오히려 성능 저하

- 종류

  - 범위 분할: 지정한 열의 값을 기준으로 분할
  - 해시 분할: 해시함수를 적용한 결과 값에 따라 데이터 분할. 데이터를 고르게 분산할 때 유용하지만, 특정 데이터가 어디에 있는지 판단할 수 없다. 데이터 값이 고른 컬럼에 효과적이다

  - 조합 분할: 범위 분할로 분할한 다음 해시 함수를 적용하여 다시 분할하는 방식이다. 범위 분할을 거치고도 파티션이 너무 큰 경우 유용하다.

- 파티션키 설정시 데이터 분포가 양호한 칼럼(날짜, 파티션 간 이동이 없는 컬럼 등)을 파티션키로 선정한다.



### 인덱스 파티션

- 파티션된 테이블의 데이터를 관리하기 위해 인덱스를 나누는 것이다.
  - Local Partitioned Index: 테이블 파티션과 인덱스 파티션이 1:1이 되도록 파티셔닝
  - Global Partitioned Index: 테이블 파티션과 인덱스 파티션이 독립적으로 구성되도록 파티셔닝 한다.
  - Local Partitioned Index가 관리가 더 쉽다.
- 인덱스 파티션 키 컬럼의 위치에 따라 Prefixed Partitioned Index와 Non-prefixed Partitioned Index로 구분된다. 인덱스 파티션 키와 인덱스 첫번째 컬럼이 같으면 Prefixed Partitioned Index이다.





### 기출문제 따라잡기

1. 물리 데이터 저장소의 파티션 설계에서 파티션 유형으로 옳지 않은 것은?

   파티션의 유형으로는 범위 분할, 해시 분할, 조합 분할이 있다.

2. 다음 중 파티션에 대한 설명으로 틀린 것은?

   테이블 크기가 작으면 파티션이 악효과이다.



## 97. 데이터베이스 용량 설계



### 데이터베이스 용량 설계

- 데이터가 저장될 공간을 정의하는 것이다
- 용량을 정확히 산정하여 디스크의 저장공간을 효과적으로 사용하고 확장성과 가용성을 높이고자 함에 사용된다.
- 디스크에 대한 입출력 경합이 최소화되도록 설계하여 데이터 접근성을 향상시킬 수 있다.
  - 테이블의 테이블 스페이스와 인덱스의 테이블 스페이스를 분리하여 구성
  - 테이블 스페이스와 임시 테이블 스페이스를 분리하여 구성
  - 테이블을 마스터 테이블과 트랜잭션 테이블로 분류
- 데이터베이스에 생성되는 오브젝트의 용량 추가 할당(익스텐트) 의 발생을 최소화하여 성능을 향상시킨다




### 데이터베이스 용량 분석 절차

1. 데이터 예상 건수, 로우 길이, 보존 기간, 증가율 등 기초자료를 수집하여 용량을 분석한다.

2. 분석된 자료를 바탕으로 DBMS에 이용될 테이블, 인덱스 등 오브젝트 별 용량 산정한다

3. 테이블과 인덱스의 테이블 스페이스 용량을 산정한다

   테이블의 용량을 모두 더한 값에 40퍼센트를 추가하여 산정한다.

4. 데이터베이스에 저장될 모든 데이터 용량과 데이터베이스 설치 및 관리를 위한 시스템 용량을 합해 디스크 용량을 산정한다.



### 기출문제 따라잡기

1. 데이터베이스 용량 설계에 대한 내용에서 옳지 않은 것은?

   테이블의 테이블 스페이스와 인덱스의 테이블 스페이스를 분리하여 구성하는 것이 접근성 향상에 도움이 된다.

2. 다음 중 데이터 베이스 용량 설계에 대한 설명으로 틀린 것은?

   오브젝트의 익스텐트 발생이 최소화 되도록 설계한다.





## 98. 분산 데이터베이스 설계



### 분산 데이터 베이스

- 논리적으로는 하나의 시스템에 속하지만 물리적으로는 네트워크를 통해 연결된 여러 개의 컴퓨터 사이트에 분산되어 있는 데이터베이스를 말한다.
- 데이터의 처리나 이용이 많은 지역에 위치시켜서 처리가 해당 지역에서 해결될 수 있도록 한다
- 분산 처리기, 분산 데이터베이스, 통신 네트워크로 이루어진다.
- 설계 고려사항
  - 작업 부하의 노드별 분산 정책
  - 지역의 자치성 보장 정책
  - 데이터의 일관성 정책
  - 사이트나 회선의 고장으로부터 회복기능
  - 통신 네트워크를 통한 원격 접근 기능

- 목표

  - 위치 투명성: 데이터베이스의 실제 위치 없이 논리적 명칭만으로 액세스 가능
  - 중복 투명성: 동일 데이터가 여러 곳에 중복되어 있더라도 사용자는 하나의 데이터만 존재하는 것처럼 사용하고, 시스템은 여러 자료에 대한 작업을 수행한다
  - 병행 투명성: 다수의 트랜잭션이 동시에 수행되어도 결과에 영향이 없다
  - 장애 투명성: 다른 장애에도 불구하고 트랜잭션을 정확하게 처리한다.

- 단점

  - DBMS가 수행할 기능이 복잡해진다
  - 데이터베이스 설계가 어렵다
  - 소프트웨어 개발 비용과 처리비용이 증가한다
  - 잠재적 오류가 증가한다.
  - 잘못 설계된 분산 데이터베이스는 복잡성 증가, 응답 속도 저하, 비용 증가가 발생한다.

- 분산, 분할, 할당의 방법으로 설계한다

  - 분산: 테이블을 각기 다른 서버에 분산시켜 배치한다. 테이블의 구조는 변경하지 않으며 다른 데이터베이스의 테이블과 중복되지 않도록 한다

  - 분할: 데이터를 분할하여 분산시키는 것이다

    분할 규칙

    - 완전성: 전체 데이터를 대상으로 분할
    - 재구성: 분할된 데이터는 관계 연산을 활용하여 본래의 데이터로 재구성할 수 있어야 한다
    - 상호 중첩 배제: 서로 다른 분할의 항목에 속하면 안된다(1개에만 속해야 한다)

    주요 분할 방법

    - 수평 분할: row 단위로 분할
    - 수직 분할: 컬럼 단위로 분할

  - 할당: 동일한 분할을 여러개의 서버에 생성하는 분산 방법으로, 중복이 없는 할당과 중복이 있는 할당으로 나뉜다.



### 기출문제 따라잡기

1. 분산 데이터베이스의 장점으로 거리가 먼 것은?

   개발 비용이 비싸다

2. 분산 데이터베이스의 투명성에 해당하지 않는 것은?

   투명성에는 위치 투명성, 중복 투명성, 장애 투명성, 병행 투명성이 있다.

3. 분산 데이터베이스 시스템의 장점으로 거리가 먼 것은?

   분산 데이터베이스를 사용하면 잠재적 오류 발생 가능성이 늘어난다.

4. 분산 데이터베이스 설계 시 고려사항으로 옳지 않은 것은?

   분산데이터베이스는 중복 투명성이 보장되어야 하며, 따라서 중복성 보장이 제공되면 안된다.

5. 분산 데이터 베이스 목표 중 "데이터베이스의 분산된 물리적 환경에서 특정 지역의 컴퓨터 시스템이나 네트워크에 장애가 발생해도 데이터 무결성이 보장된다"는 것과 관계 있는 것은?

   장애 투명성





## 99. 데이터베이스 이중화 / 서버 클러스터링



### 데이터베이스 이중화

- 시스템 오류로 인한 데이터베이스 서비스 중단이나 물리적 손상 발생 시 이를 복구하기 위해 동일한 데이터베이스를 복제하여 관리하는 것이다.
- 어플리케이션을 여러개의 데이터베이스로 분산시켜 처리해서 부하를 줄일 수 있다
- 손쉽게 백업 서버를 운영할 수 있다.
- 이중화의 분류
  - Eager 기법: 트랜잭션 수행 중 변경이 발생하면 이중화된 모든 데이터베이스에 즉시 전달하여 적용되도록 하는 것
  - Lazy 기법: 트랜잭션의 수행이 종료되면 변경 사실을 새로운 트랜잭션으로 작성하여 각 이중화된 데이터베이스에 전달한다
- 이중화 구성 방법
  - 활동 - 대기 방법: 한 DB가 서비스중이면 다른 DB는 대기하고 있다가 장애가 발생하면 서비스를 대신 수행. 구성과 관리가 쉬워 많이 사용된다.
  - 활동 - 활동 방법: 두 개의 DB가 서로 다른 서비스를 제공한다. 처리율이 높지만 구성 방법과 설정이 복잡하다.



### 클러스터링

- 두 대 이상의 서버를 하나의 서버처럼 운영하는 기술이다.
- 서버 이중화 및 공유 스토리지를 사용하여 서버의 고가용성을 제공한다.
  - 고가용성 클러스터링: 하나의 서버에 장애가 발생하면 다른 서버가 받아 처리하여 서비스 중단을 방지하는 방식으로, 일반적 클러스터링이다
  - 병렬 처리 클러스터링: 전체 처리율을 높이기 위해 하나의 작업을 여러개의 서버에서 분산하여 처리하는 방식이다.



### 기출문제 따라잡기

1. 데이터베이스 이중화에 대한 설명으로 틀린 것은?

   데이터 변경이 발생했을 때 즉시 적용하는 것은 Eager 방식이다

2. 데이터베이스 이중화에 대한 설명으로 옳지 않은 것은?

   활동 - 대기 방식이 구성과 설정, 관리가 편하다





## 100. 데이터베이스 보안 / 암호화



### 데이터베이스 보안

- 데이터베이스의 일부분 또는 전체에 권한이 없는 사용자가 액세스 하는 것을 금지하기 위해 사용되는 기술이다.

- 암호화(Encryption)을 사용하여 지정한 수신자 이외에는 내용을 알 수 없도록 하며, 지정된 수신자는 복호화(Decryption)를 수행하여 원래 데이터를 알 수 있다

  - 개인 키 암호 방식: 대칭 암호 방식 또는 단일키 암호화 기법이라고도 한다

    비밀키는 제 3자에겐 주지 않고, 권한 있는 사용자만 나누어 가진다

    전위 기법, 대체 기법, 대수 기법, 합성 기법 등이 있다.

  - 공개키 암호 방식

    서로 다른 키로 데이터를 암호화하고 복호화 한다.

    암호화할 때 쓰는 키는 공개키이지만, 복호화할때 쓰는 키는 비밀키로 관리자가 관리한다. 비대칭 암호 방식이라고도 하며 RSA 기법이 있다.



### 기출문제 따라잡기

1. 암호화 기법 중 암호화 알고리즘과 암호화키는 공개해서 누구든 암호문을 만들 수 있지만 해독키는 비밀로 관리되는 방법은?

   공중키 암호방식이라고 한다

2. 데이터베이스 보안에 대한 설명으로 옳지 않은 것은?

   사용자의 권한 부여는 관리자의 결정으로 정해진다.





## 101.데이터베이스 보안 - 접근 통제



### 접근 통제

- 데이터가 저장된 객체와 사용자 사이의 정보 흐름을 제한하는 것이다.

- 비인가된 사용자의 접근 감시, 접근 요구자의 사용자 식별, 접근 요구의 정당성 확인 및 기록 등으로 통제한다

- 통제 기술

  - 임의 접근 통제(DAC, Discretionary Access Control)

    사용자의 신원에 따라 접근 권한을 부여하는 방식이다.

    데이터 소유자가 접근 통제 권한을 지정하고 제어한다

    객체를 생성한 사용자가 생성된 객체에 대한 권한을 부여받고, 부여된 권한을 다른 사용자에게 허가할 수도 있다.

    GRANT와 REVOKE 명령어를 사용한다

  - 강제 접근 통제(MAC, Mandatory Access Control)

    주체의 등급과 데이터의 등급을 비교하여 큰지 같은지 작은지를 통해서 권한을 부여한다

    크면 R, U, C 모두 불가, 같으면 모두 가능, 낮으면 R만 가능

  - 역할기반 접근 통제(RBAC, Role Based Access Control)

    사용자의 역할에 따라 접근 권한을 부여하는 방식이다

    중앙 관리자가 접근통제 권한을 지정한다

    다중 프로그래밍 환경에 최적화된 방식이다

- 접근 통제의 3요소는 접근통제 정책, 접근 통제 메커니즘, 접근통제 보안 모델이다

  - 접근통제 정책

    - 신분 기반 정책: 주체나 그룹의 신분에 근거하여 객체의 접근을 제한하는 방법
      - IBP(Individual-Based Policy): 최소 권한 정책, 단일 주체에게 하나의 객체에 대한 허가 부여
      - GBP(Group-Based Policy): 복수 주체에 하나의 객체에 대한 허가를 부여한다
    - 규칙 기반 정책: 주체가 갖는 권한에 근거하여 객체의 접근을 제한하는 방법
      - MLP(Multi-Level Policy): 사용자 및 객체별로 지정된 기밀 분류에 따른 정책
      - CBP(Compartment-Based Policy): 집단별로 지정된 기밀 허가에 따른 정책
    - 역할 기반 정책: GBP의 변형된 정책으로 주체의 신분이 아니라 주체가 맡은 역할에 근거하여 객체의 접근을 제한하는 방법이다

  - 접근 통제 매커니즘

    정의된 접근 통제 정책을 구현하는 기술적인 방법이다

    - 접근 통제 목록: 객체를 기준으로 특정 객체에 대해 어떤 주체가 어떤 행위를 할 수 있는지 기술한 목록
    - 능력 리스트: 주체를 기준으로 주체에게 허가된 자원 및 권한을 기록한 목록이다
    - 보안 등급: 주체나 객체 등에 부여된 보안 속성의 집합으로 이 등급을 기반으로 접근 승인 여부가 결정된다.
    - 패스워드 : 주체가 자신임을 증명할 때 사용하는 인증 방법이다
    - 암호화

  - 접근통제보안 모델

    보안 정책을 구현하기 위한 정형화된 모델

    - 기밀성 모델: 군사적인 목적으로 개발된 최초의 수학적 모델. 군대와 같은 특수 환경에서 사용

      제약 조건

      - 단순 보안 규칙: 자신보다 높은 등급의 객체를 읽을 수 없다
      - 스타 보안 규칙: 주체는 자신보다 낮은 등급의 객체에 정보를 쓸 수 없다
      - 강한 스타 보안 규칙: 주체는 자신과 등급이 다른 객체를 읽거나 쓸 수 없다.

    - 무결성 모델: 기밀성 모델에서 발생하는 불법적인 정보 변경을 방지하기 위해 개발된 모델

      데이터의 일관성 유지에 중점을 두어서 개발

      - 단순 무결성 규칙: 자신보다 낮은 등급의 객체를 읽을 수 없다
      - 스타 무결성 규칙: 자신보다 높은 등급의 객체에 쓸 수 없다.

    - 접근 통제 모델: 접근 통제 메커니즘을 보안 모델로 발전 시킨 것

      - 접근 통제 행렬: 접근 통제를 관리하기 위한 보안 모델

        행은 사용자, 열은 객체를 의미하며 가능한 작업을 적어서 표로 만든다.

- 접근 통제 조건: 접근통제 매커니즘의 취약점을 보완하기 위해 추가로 부가하여 적용하는 조건

  - 값 종속 통제: 객체에 저장된 값에 따라 다르게 접근통제를 허용해야 하는 경우에 사용한다.
  - 다중 사용자 통제: 다수의 사용자가 동시에 접근을 요구하는 경우에 사용된다
  - 컨텍스트 기반 통제: 특정 시간, 네트워크 주소, 접근 경로, 인증 수준 등에 근거하여 접근을 제어하는 방식

- 사용자나 애플리케이션이 데이터베이스에 접근하여 수행한 모든 활동을 기록하는 것을 감사 추적이라고 한다.





### 기출문제 따라잡기

1. 접근 통제 정책에 대한 설명이다 (ㄱ)에 들어갈 내용으로 옳은 것은?

   정책변경이 어렵고, 시스템이 권한을 부여하는 것을 Mandaory(강제) 기반 접근통제라고 한다

2. 다음 중 접근통제의 3요소가 아닌 것은?

   접근 통제 정책, 보안 모델, 매커니즘이 있다.

3. 접근통제 매커니즘에 대한 설명으로 옳지 않은 것은?

   보안 정책을 구현하기 위한 정형화된 모델은 접근통제 보안 모델이다

4. 접근통제 보안 모델에 대한 설명으로 틀린 것은?

   인가된 사용자만 접할 수 있는 것을 기밀성 모델이라고 한다.

