# 알고리즘



### 1. stable sort와 unstable sort가 무엇인지 예시와 함께 설명하고, 어떤 알고리즘들이 있는지 분류해주세요.

- stable sort는 sorting 작업을 진행한 전과 후에, 같은 분류 기준을 가진 node들의 순서가 변하지 않는 것을 말합니다. 예를 들어 13, 36, 24, 10, 14 과 같이 두자리 자연수 5개가 있을 때, 10의 자리 기준 오름 차순으로 정렬한다고 했을때, 13, 10, 14, 24, 36 처럼 13, 10, 14 순서가 유지된다면 stable sort이고, 10, 14, 13, 24, 36 처럼 순서가 유지되지 않으면 unstable sort라고 합니다. stable sort의 종류에는 bubble sort, insertion sort, Merge Sort 가 있고, Unstable Sort의 종류에는 Selection Sort, Heap Sort, Quick Sort 등이 있습니다.





### 2. Fibonacci에서의 재귀, 동적프로그래밍, 반복의 세 가지 방식에 대한 시간복잡도와 공간복잡도

```python
# 재귀
def fibonacci_re(n):
		if n < 2:
				return n
		return fibo(n-1) + fibo(n-2) # recursion 한개가 2개의 연산을 불러 일으킨다. 
# n번째 피보나치연산은 depth가 n인 트리의 노드 수 만큼 연산이 일어나므로 2^N 
																	
# 시간복잡도: O(2^N)
# 공간복잡도: recursion마다 스택에 1개씩 쌓이므로 길이 n의 스택이 필요 : O(N) (?)


# DP
def fibonacci_dp(n):
		dp = []
		dp.append(0)
		dp.append(1)
		for i in range(n-1):  # n번 반복
				dp.append(dp[-1] + dp[-2])  # 길이가 n인 dp배열에서 index로 조회 및 덧셈: O(1)
		return dp[n]

# 시간복잡도: O(N)
# 공간복잡도: 길이가 n인 배열을 사용하므로 O(N)


# 반복
def fibonacci_loop(n):
		a, b = 0, 1
		for i in range(n-1): 
				a, b = b, a+b     # 덧셈과 할당을 n번 반복하므로 O(N)
		return b

# 시간복잡도: O(N)
# 공간복잡도: 변수 두개만 사용하므로 O(1)
```





### 3. Quick sort가 일어나는 과정을 설명해주세요.

- Quick Sort는 분할 정복 방법(Divide and Conquer)을 통해서 배열을 정렬합니다.
- 분할 정렬은 분할, 정복, 결합이 일어나면서 정렬이 이루어집니다.
  - 분할: 정해진 pivot을 기준을 작은 원소와 큰 원소, 두 배열로 원본 배열을 분할합니다.
  - 정복: 부분 배열을 정렬합니다. 모든 부분 배열이 길이가 1이 되지 않으면, 분할과 정복을 recursion을 통해서 반복합니다.
  - 결합: 최종적으로 길이가 1이 된 배열들을 합칩니다.
- 퀵소트는 좌측엔 pivot보다 작은 원소, 우측엔 pivot보다 큰 원소로 이루어진 배열로 분할 할 것이기 때문에, 배열에서 가장 좌측에서 시작하는 index와 우측에서 시작하는 index가 서로에게 다가오며, 자신의 방향의 배열과 맞지 않은 원소를 탐색합니다. 찾았다면 두 인덱스에 있는 값을 교환합니다. 이 과정을 반복하다 보면 언젠가 두 인덱스가 교차하게 되는데, 그 때 한번의 분할 정복이 끝나게 됩니다.
- 갈라진 두 배열을 각가 다시 quick sort에 넣고 반환값을 합쳐서 최종 결과물이 나오는데, 이 quick sort에 들어간 배열은 그 안에서 또다시 분할 정복이 이루어지게 되고, 길이가 1인 배열은 그대로 리턴되면서 병합의 과정을 거칩니다.
- O(NlogN)의 시간복잡도를 가집니다.





### 4. **Merge sort의 장단점과 일어나는 과정을 설명해주세요.**

- Merge Sort는 분할 정복 방법을 통해서 배열을 정렬합니다.
  - 분할: 배열의 길이가 1이 될 때 까지 배열을 두개로 분할합니다.
  - 정복: 부분 배열을 정렬합니다. Merge Sort의 경우 배열의 길이가 1이  될때까지는 정렬이 이루어지지 않습니다.
  - 결합: 정렬된 부분 배열을 하나의 배열에 합칩니다.
- Merge Sort의 결합과정은 두 부분배열이 정렬되었다는 가정하에 진행되며,  두 부분배열의 앞 index의 원소부터 서로 비교하며 작은 원소를 합병 될 리스트에 차례로 집어 넣습니다. 한쪽 리스트가 동나면 나머지 리스트의 원소를 그대로 뒤에 추가합니다. 이렇게 하나의 원소로 이루어진 부분배열로 모두 쪼개졌다가 결합 과정을 거쳐서 정렬된 배열로 재탄생합니다.
- 반으로 나누는 과정을 거치므로, 최악의 경우에도 O(NlogN)의 시간복잡도를 보장합니다. 하지만 길이가 n인 리스트를 정렬하기 위해서 길이가 n인 임시 배열이 하나 더 필요하므로 공간 더 소요됩니다.



