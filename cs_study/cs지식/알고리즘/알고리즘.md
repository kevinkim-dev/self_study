# 알고리즘



### 1. stable sort와 unstable sort가 무엇인지 예시와 함께 설명하고, 어떤 알고리즘들이 있는지 분류해주세요.

- stable sort는 sorting 작업을 진행한 전과 후에, 같은 분류 기준을 가진 node들의 순서가 변하지 않는 것을 말합니다. 예를 들어 13, 36, 24, 10, 14 과 같이 두자리 자연수 5개가 있을 때, 10의 자리 기준 오름 차순으로 정렬한다고 했을때, 13, 10, 14, 24, 36 처럼 13, 10, 14 순서가 유지된다면 stable sort이고, 10, 14, 13, 24, 36 처럼 순서가 유지되지 않으면 unstable sort라고 합니다. stable sort의 종류에는 bubble sort, insertion sort, Merge Sort 가 있고, Unstable Sort의 종류에는 Selection Sort, Heap Sort, Quick Sort 등이 있습니다.





### 2. Fibonacci에서의 재귀, 동적프로그래밍, 반복의 세 가지 방식에 대한 시간복잡도와 공간복잡도

```python
# 재귀
def fibonacci_re(n):
		if n < 2:
				return n
		return fibo(n-1) + fibo(n-2) # recursion 한개가 2개의 연산을 불러 일으킨다. 
# n번째 피보나치연산은 depth가 n인 트리의 노드 수 만큼 연산이 일어나므로 2^N 
																	
# 시간복잡도: O(2^N)
# 공간복잡도: recursion마다 스택에 1개씩 쌓이므로 길이 n의 스택이 필요 : O(N) (?)


# DP
def fibonacci_dp(n):
		dp = []
		dp.append(0)
		dp.append(1)
		for i in range(n-1):  # n번 반복
				dp.append(dp[-1] + dp[-2])  # 길이가 n인 dp배열에서 index로 조회 및 덧셈: O(1)
		return dp[n]

# 시간복잡도: O(N)
# 공간복잡도: 길이가 n인 배열을 사용하므로 O(N)


# 반복
def fibonacci_loop(n):
		a, b = 0, 1
		for i in range(n-1): 
				a, b = b, a+b     # 덧셈과 할당을 n번 반복하므로 O(N)
		return b

# 시간복잡도: O(N)
# 공간복잡도: 변수 두개만 사용하므로 O(1)
```

