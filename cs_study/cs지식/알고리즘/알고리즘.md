# 알고리즘



### 1. stable sort와 unstable sort가 무엇인지 예시와 함께 설명하고, 어떤 알고리즘들이 있는지 분류해주세요.

- stable sort는 sorting 작업을 진행한 전과 후에, 같은 분류 기준을 가진 node들의 순서가 변하지 않는 것을 말합니다. 예를 들어 13, 36, 24, 10, 14 과 같이 두자리 자연수 5개가 있을 때, 10의 자리 기준 오름 차순으로 정렬한다고 했을때, 13, 10, 14, 24, 36 처럼 13, 10, 14 순서가 유지된다면 stable sort이고, 10, 14, 13, 24, 36 처럼 순서가 유지되지 않으면 unstable sort라고 합니다. stable sort의 종류에는 bubble sort, insertion sort, Merge Sort 가 있고, Unstable Sort의 종류에는 Selection Sort, Heap Sort, Quick Sort 등이 있습니다.





### 2. Fibonacci에서의 재귀, 동적프로그래밍, 반복의 세 가지 방식에 대한 시간복잡도와 공간복잡도

```python
# 재귀
def fibonacci_re(n):
		if n < 2:
				return n
		return fibo(n-1) + fibo(n-2) # recursion 한개가 2개의 연산을 불러 일으킨다. 
# n번째 피보나치연산은 depth가 n인 트리의 노드 수 만큼 연산이 일어나므로 2^N 
																	
# 시간복잡도: O(2^N)
# 공간복잡도: recursion마다 스택에 1개씩 쌓이므로 길이 n의 스택이 필요 : O(N) (?)


# DP
def fibonacci_dp(n):
		dp = []
		dp.append(0)
		dp.append(1)
		for i in range(n-1):  # n번 반복
				dp.append(dp[-1] + dp[-2])  # 길이가 n인 dp배열에서 index로 조회 및 덧셈: O(1)
		return dp[n]

# 시간복잡도: O(N)
# 공간복잡도: 길이가 n인 배열을 사용하므로 O(N)


# 반복
def fibonacci_loop(n):
		a, b = 0, 1
		for i in range(n-1): 
				a, b = b, a+b     # 덧셈과 할당을 n번 반복하므로 O(N)
		return b

# 시간복잡도: O(N)
# 공간복잡도: 변수 두개만 사용하므로 O(1)
```





### 3. Quick sort가 일어나는 과정을 설명해주세요.

- Quick Sort는 분할 정복 방법(Divide and Conquer)을 통해서 배열을 정렬합니다.
- 분할 정렬은 분할, 정복, 결합이 일어나면서 정렬이 이루어집니다.
  - 분할: 정해진 pivot을 기준을 작은 원소와 큰 원소, 두 배열로 원본 배열을 분할합니다.
  - 정복: 부분 배열을 정렬합니다. 모든 부분 배열이 길이가 1이 되지 않으면, 분할과 정복을 recursion을 통해서 반복합니다.
  - 결합: 최종적으로 길이가 1이 된 배열들을 합칩니다.
- 퀵소트는 좌측엔 pivot보다 작은 원소, 우측엔 pivot보다 큰 원소로 이루어진 배열로 분할 할 것이기 때문에, 배열에서 가장 좌측에서 시작하는 index와 우측에서 시작하는 index가 서로에게 다가오며, 자신의 방향의 배열과 맞지 않은 원소를 탐색합니다. 찾았다면 두 인덱스에 있는 값을 교환합니다. 이 과정을 반복하다 보면 언젠가 두 인덱스가 교차하게 되는데, 그 때 한번의 분할 정복이 끝나게 됩니다.
- 갈라진 두 배열을 각가 다시 quick sort에 넣고 반환값을 합쳐서 최종 결과물이 나오는데, 이 quick sort에 들어간 배열은 그 안에서 또다시 분할 정복이 이루어지게 되고, 길이가 1인 배열은 그대로 리턴되면서 병합의 과정을 거칩니다.
- O(NlogN)의 시간복잡도를 가집니다.





### 4. **Merge sort의 장단점과 일어나는 과정을 설명해주세요.**

- Merge Sort는 분할 정복 방법을 통해서 배열을 정렬합니다.
  - 분할: 배열의 길이가 1이 될 때 까지 배열을 두개로 분할합니다.
  - 정복: 부분 배열을 정렬합니다. Merge Sort의 경우 배열의 길이가 1이  될때까지는 정렬이 이루어지지 않습니다.
  - 결합: 정렬된 부분 배열을 하나의 배열에 합칩니다.
- Merge Sort의 결합과정은 두 부분배열이 정렬되었다는 가정하에 진행되며,  두 부분배열의 앞 index의 원소부터 서로 비교하며 작은 원소를 합병 될 리스트에 차례로 집어 넣습니다. 한쪽 리스트가 동나면 나머지 리스트의 원소를 그대로 뒤에 추가합니다. 이렇게 하나의 원소로 이루어진 부분배열로 모두 쪼개졌다가 결합 과정을 거쳐서 정렬된 배열로 재탄생합니다.
- 반으로 나누는 과정을 거치므로, 최악의 경우에도 O(NlogN)의 시간복잡도를 보장합니다. 하지만 길이가 n인 리스트를 정렬하기 위해서 길이가 n인 임시 배열이 하나 더 필요하므로 공간 더 소요됩니다.



### 5. Greedy 알고리즘에 대해 설명하고, 단점과 사용하는 상황을 설명해주세요. 

- Greedy 알고리즘(탐욕 알고리즘)은 해당 선택 이후 변화를 생각하지 않고, 그 순간 가장 최선화된 선택을 해 나가는 알고리즘을 말합니다. 당장 최선화된 선택을 하기 때문에 전체적으로 봤을 때는 최적의 답을 주지 못하는 경우가 있습니다. 
  - 예를 들어서 100원, 80원, 40원, 10원짜리 동전으로 120원을 거슬러주는 상황이 있습니다. Greedy알고리즘을 쓰면 100원을 먼저 주는게 최선이기에 100원짜리 한개를 사용하고 남은 20원을 10원 두개로 해결해서 총 3개의 동전을 씁니다. 하지만, 진짜 최선해는 80, 40원 두개 만으로 해결할 수 있습니다.
- 따라서 Greedy 알고리즘은 Greedy 알고리즘을 사용해도, 즉 모든 상황에서 그 상황에서의 최선값을 찾아나가는 것이 최선 해를 찾는 방법임이 보장되는 경우에만 사용해야 합니다. 또한 최선해를 찾는 방법이 아닌, 혹은 최선해를 찾는 방법이 어려운 경우 대안으로 최적해를 찾아야하는 문제에서는 사용할 수 있습니다.eㅁ





### 6. Heap에 대해 설명하고 삽입, 삭제 과정을 설명해주세요.

- 힙은 특별한 조건을 만족하는 완전 이진 트리를 말합니다.
  - 완전 이진 트리는 모든 노드에 자식이 2개 이하이면서 노드는 위에서부터, 왼쪽에서부터 채워지는 규칙을 가진 트리입니다.
- 최대 힙과 최소 힙 크게 두가지가 있는데, 노드간의 관계에서 최소힙은 항상 parent가 child보다 작아야하고, 최대힙은 항상 parent가 child보다 커야합니다.
- 삽입 연산의 경우, 먼저 완전 이진트리를 만족시키는 위치(최 하단, 가장 좌측)에 leaf node로 삽입합니다. 그 후 최대 힙, 혹은 최소 힙을 만족할 때 까지 부모 노드와 교환하는 형식을 통해 자기 자리로 이동합니다.
- 삭제 연산의 경우, 먼저 삭제 할 node에 데이터를 지우고, 그 자리에 node가 삭제되어도 완전 이진 트리를 유지하는 node의 데이터, 즉 가장 우측 leaf node의 데이터를 넣고, 해당 leaf node를 삭제합니다. 마찬가지로 최대힙 혹은 최소 힙을 만족할 때 까지 교환을 합니다.
- 완전 이진 트리로 구성되어 있는 힙 트리를, 배열에 담아 저장하고, 그 배열을 통해서 빠르게 최대, 최소값을 찾아낼 수 있으며, 시간 복잡도는 O(NlogN) 이 됩니다.