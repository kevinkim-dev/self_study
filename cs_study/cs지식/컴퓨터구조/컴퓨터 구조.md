# 컴퓨터 구조





### 1. 캐시메모리에 대해서 설명해주세요



- 일반적으로 저장공간은 크면 클수록 속도가 느려지고, 크기가 작을 수록 속도가 빨라지는데, CPU의 레지스터는 속도가 빠른 반면 공간이 작고, 보통의 저장공간은 크기가 큰 반면 속도가 느립니다. 그 사이의 간극을 줄이기 위해 적당한 속도와 적당한 크기를 가진 메모리가 중간단계에서 중재를 맡고 있는데 이것을 캐시메모리라고 합니다.

- 어떤 데이터가 필요할 때 먼저 캐시를 훑어 해당 정보가 있는지 확인합니다. 이 때 정보가 캐시에 있다면 메인 메모리까지 가지 않고 빠르게 캐시에서 정보를 불러올 수 있으며, 이 것을 cache hit이라고 합니다. 캐시에 없다면 메인메모리까지 가서 가져오는 느린 과정을 겪는데, 이것을 cache miss라고 하며, 전체 데이터 접근 횟수에서 cache hit의 비율인 hit ratio를 최고로 높일 수 있는 저장 전략이 필요합니다.

- 캐시에서 읽기 뿐만 아니라 쓰기 작업을 수행 할 때 두가지 방법이 있습니다

  - Write Through: 캐시에 해당 데이터와, 메모리의 데이터에 모두 쓰는 방법입니다. 설계구조가 간단하지만, 결국 메인 메모리에 접근해야하므로 상대적으로 느립니다.

  - Write Back: 캐시에만 해당 데이터를 쓰는 방식입니다. 캐시에 해당 블록이 남아있는 동안에는 메인 메모리에서 조회하지 않고 캐시에서 조회하므로, 굳이 메모리에 접근하지 않아도 되기 때문에 사용하는 방법으로 속도가 빠릅니다. 다만, cache에 새로운 블럭을 가져와야 할 때, 메모리에 변경 사항이 기록되지 않은블럭이 지워져야 한다면 해당 블럭을 메모리에 덮어씌우는 추가 로직이 필요합니다

- 캐시는 시간적 지역성과 공간적 지역성을 따르는데, 짧은 시간 텀 내에 또 조회될 가능성이 높다는 시간적 지역성에 따라 cache miss로 인해 메인메모리에서 한번 참조된 데이터 블록은 cache memory에 저장됩니다. 하지만 cache memory는 거의 항상 꽉 차 있으므로, 이 경우마다 다른 블럭을 삭제해야하는데, 이것을 캐시 메모리 교체라고 하며, 효율적인 교체를 위한 여러 알고리즘이 존재합니다

  - random: 임의로 교체될 페이지를 선정하며, 가장 간단한 로직을 가지고 있어 오버헤드가 적습니다.
  - FIFO: cache에 들어온지 가장 오래된 페이지를 교체합니다. 로직이 간단하지만, 가장 최근에 조회된 페이지더라도 가장 먼저 cache에 들어온 페이지라면 교체될 수 있습니다.
  - LFU: 사용횟수가 가장 적은 페이지를 교체. 합리적 변경으로 보이지만, 이것 역시 가장 최근에 조회된 페이지가 교체될 가능성이 있습니다.
  - LRU: 가장 오랫동안 사용되지 않은 페이지를 교체합니다.
  - NRU: 가장 오랫동안 사용되지 않은 페이지를 교체합니다. LRU와는 다르게, 참조와 수정으로 나누어 4가지 우선순위에 따라 교체됩니다.(참조되고 수정된, 참조됐지만 수정되지 않은, 참조되지 않았지만 수정된, 참조되지도 않고 수정되지도 않은 의 순서의 우선순위를 가집니다.)

  - MFU: 가장 참조횟수가 많은 페이지를 교체 (이미 많이 사용했으므로 사용하지 않을 것이라는 논리를 가진 페이지 교체)





### 2. call by value, call by address, call by reference 차이

- call by value와 address는 C언어에 있던 개념이며, call by reference 는 call by address를 대체하는, C++에서 생긴 개념입니다.
- call by value는 메모리에서 변수의 값 자체를 복사하는 개념입니다. 따라서 복사한 값을 변화해도 원본 값은 바뀌지 않습니다.
- call by address는 변수의 주소값을 복사해와서 할당하는 개념입니다. 즉 해당 변수값의 주소의 값을 변화시킨다면 원본 값을 바꿀 수 있습니다.
- call by reference는 call by address와 동일하게 해당 변수 원본값을 변화시키지만, 주소 대신 레퍼런스 값을(?) 할당합니다. 따라서 call by address는 고정 4byte를 사용하는 반면 메모리 사용을 줄일 수 있습니다.





### 3. 컴퓨터의 덧셈기,뺄셈기의 동작 원리에 대해 설명해주세요

- 컴퓨터에는 and 연산과 or연산을 이용한 논리회로인 가산기가 존재합니다. 0과 1의 인풋으로 sum과 carry(올림)을 출력하는 반가산기(Half Adder)가 있고, 두 자리 수 이상의 합을 구하기 위해 올림까지 더해주는, 반가산기 두개를 합친(a + b + carry) 전가산기(Full Adder)가 있습니다.
- Full Adder를 n개 연결하면 n-bit adder를 구현할 수 있으며, 이를 통해서 덧셈을 계산할 수 있습니다.
- a - b = a + (-b) 로 빼는 수를 음수로 바꾸어 더하면 가산기로 뺄셈을 계산할 수 있습니다. 따라서 컴퓨터는 뺄셈을 계산할 때, 빼는 수를 2의 보수를 통해서 음수로 전환하고, 가산기에 넣고 뺄셈을 계산합니다



### 4. Big Endian과 Little Endian에 대해 설명해주세요

- 컴퓨터의 메모리는 기본 단위가 1바이트인데, 1 바이트는 8bit이므로 0~255까지, 16진수로는 00~FF까지 두자리수를 기록할 수 있습니다. 따라서 어떤 값을 저장할 때 16진수 뒤에서부터 두자리 씩 끊어서 주소에 할당하여 저장하게 되는데, LSB(Least Significant Bit: 가장 오른쪽의 비트)가 포함된 것부터 두자리씩 주소에 저장하면 Little Endian, MSB가 포함된 것부터 저장하면 Big Endian이 됩니다.
  - 예를 들어서 0x13FB4A 라는 수가 있을 때, 13, FB, 4A로 2자리씩 끊어서 저장하게 됩니다. MSB는 맨 앞의 1에 포함되어있고, LSB는 맨 뒤의 A에 포함되어있는데, 메모리에 13, FB, 4A 순서로 저장하면 Big Endian, 4A, FB,13 순서로 저장하면 Little Endian입니다.
- 메모리에서 연속된 주소를 읽을 때 낮은 주소부터 읽는 컴퓨터의 특성상 Big Endian은 사람이 글을 읽는 방식과 비슷하기 때문에 "사람 친화적"인 저장 방식입니다. 즉 프로그래밍, 디버깅에 편리하다는 장점이 있으며, 두 수를 비교하는 경우에도, MSB부터 계산하다가 어느 순간 차이가 나면 더이상 비교할 필요가 없기 때문에 비교연산에 장점이 있습니다. 한편, Little Endian은 "컴퓨터 친화적"인 저장방식입니다. 컴퓨터의 주된 연산인 덧셈은 사람이 덧셈을 하듯이, 올림의 여부가 다음 자리수 덧셈에 영향을 주기 때문에, LSB부터 연산을 하게되는데, Little Endian을 이용하면 LSB가 포함된 자리부터 읽어오기 때문에 순차적인 덧셈연산이 가능합니다.