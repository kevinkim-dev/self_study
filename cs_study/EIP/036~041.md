# CS_Study_정보처리기사 2주차

> 04.07 ~ 04.13
>
> 제 2과목 데이터베이스 구축 - 1) 데이터 입/출력 구현
>
> 36장~41장
>
> by. 김승현



## 36. 자료구조





### 자료구조

- 자료구조는 일련의 자료들을 조직하고 구조화 하는 것이다.
- 자료구조에 따라 프로그램의 실행시간이 달라진다
- 어떤 자료구조에서든 필요한 모든 연산이 가능하다.

- 자료구조에는 선형구조(Linear Structure)와 비선형 구조(Non-Linear Structure)가 있다
  - 선형구조
    - 배열, 선형 리스트, 스택, 큐, 데크가 있다
  - 비선형구조
    - 트리, 그래프  가 있다.



### 배열

- 정적인 자료구조로 기억장소의 추가가 어렵고, 데이터 삭제 시 데이터가 저장된 기억장소가 빈 공간이 되어 메모리 낭비가 발생한다
- 반복적인 데이터 처리 작업에 적합하다
- 첨자를 통해 접근하며( [n] ) 첨자의 갯수에 따라 n차원 배열이라고 부른다



### 선형 리스트

- 일정한 순서에 따라 나열된 자료구조이다
- 연속 리스트(Contiguous List)와 포인터를 이용하는 연결 리스트(Linked List)로 구분된다
  - Contiguous List
    - 배열과 같이 연속되는 기억장소에 저장되는 자료구조이다.
    - 중간에 데이터를 삽입하거나 제거할 수 있으나, 그 뒤의 데이터들이 밀리거나 당겨져야한다.
    - 기억장소 이용 효율이 밀도 1로 가장 높다
  - Linked List
    - 자료들이 반드시 연속적으로 배열되어 있지 않고, 노드 안에 데이터와 링크로 구성되어있으며, 링크가 다음 데이터의 주소를 담아서 선형적으로 이어지는 구조이다.
    - 포인터 주소만 바꿔주면 되므로 노드의 삽입/삭제가 용이하다
    - 중간에 빈 메모리가 존재할 수도 있으므로 기억 공간의 효율이 좋지는 않다
    - 포인터를 찾기위한 시간이 필요하므로 접근속도는 느리다



### 스택

- 리스트의 한쪽 끝으로만 자료의 삽입, 삭제 작업이 이루어지는 자료구조이다.

- 후입선출(LIFO, Last In First Out)의 구조를 가지고 있다.
- 스택의 자료구조가 꽉찬 상태로 데이터가 PUSH되면 Overflow가 발생하며, 데이터가 없는데 POP을 하면 Underflow가 발생한다
- 가장 마지막에 들어온 자료를 TOP, 가장 처음 들어온 자료를 Bottom이라고 한다.



### 큐

- 리스트의 한쪽에서 삽입, 반대쪽에서 삭제가 이루어지는 구조이다.
- 선입선출(FIFO, First In First Out)의 구조를 가지고 있다
- 큐의 시작(Front)과 끝(Rear)를 가리키는 두개의 포인터가 있다



### 그래프

- 정점 V(Vertex)와 간선 E(Edge)의 집합으로 이루어진다
- 방향성이 있는 그래프도 있고, 방향성이 없는 그래프도 있다.
- 통신망, 교통망, 이항관계, 연립방정식 등에 사용된다
- Graph에서 방향성이 있을 때, 두 vertex 사이를 돌고도는 순환이 생기는 경우를 사이클(Cycle)이 있다고 하며, Cycle이 없는 그래프는 Tree이다.



### 기출문제 따라잡기

1. 순차적인 선형 구조에 해당하는 자료구조는?

   선형구조에는 배열, 선형 리스트, 스택, 큐, 데크 등이 있으며 이 중 선형 리스트에 해당하는 Linked List는 선형구조지만, 순차적 구조가 아니므로 선형 구조가 아니다. 

2. 비선형 구조와 선형 구조가 옳게 짝지어진 것은?

   스택, 큐, 배열은 선형, 트리, 그래프는 비선형 구조이다

3. 효율적인 프로그램을 작성할 때 가장 우선적인 고려사항은 저장 공간의 효율성과 실행시간의 신속성이다. 자료구조의 선택은 프로그램 실행시간에 직접적인 영향을 준다. 자료구조에 관한 설명으로 거리가 먼 것은?

   문제의 종류에 따라 자료구조를 적합한 것을 찾는것이 좋다.

4. 첨자를 이용하여 데이터에 접근하며 기억장소의 추가가 어렵지만 반복저인 데이터 처리 작업에 가장 적합한 자료구조는?

   배열

5. 배열에 대한 설명으로 거리가 먼 것은?

   배열은 첨자를 이용하므로 포인터가 필요 없다

6. 연속 리스트의 특징이 아닌 것은?

   연속 리스트는 데이터의 추가, 삭제가 용이하지 않다. 그 뒤의 데이터들이 모두 밀리거나 당겨져야 하기 때문이다.

7. 연결 리스트에 대한 설명으로 거리가 먼 것은?

   포인터로 연결되어 있기 때문에, 해당 데이터를 찾아가기까지 시간이 오래걸려 속도가 느리다

8. 포인터를 사용하여 리스트를 나타냈을 때의 설명 중 옳지 않은 것은?

   연결 리스트는 노드를 삭제하기 쉽다. 연결된 노드와의 연결만 끊고, 후위 노드가 있다면 그 노드와 연결만 시켜주면 된다.

9. 리스트 내의 데이터 삽입, 삭제가 한쪽 끝에서 이루어지는 구조는 무엇인가?

   스택은 PUSH와 POP연산이 모두 TOP에서 이루어진다

10. n개의 노드로 구성된 무방향 그래프의 최대 간선수는?

    n개의 노드가 각각 n-1개의 노드와 간선을 가질 수 있으며, 무방향이므로 2로 나눠주면 된다. n*(n-1)/2





## 37. 트리



### 트리

- 정점(Node)과 선분(Branch)를 이용하여 사이클을 이루지 않도록 구성한 그래프의 한 종류이다.
- 가족의 계보, 조직도 등을  표현하기 적합하다.
- 트리에는 트리를 설명하기 위해 디그리(Degree, 차수, 해당의 자식 노드의 수), 레벨(루트 노드가 레벨 1이며 밑으로 내려갈수록 1씩 증가, depth라고도 함)



### 운행법

- 각 노드를 찾아가는 방법을 운행법(Traversal)이라고 한다.
  - Preorder 운행: Parent - Left - Right 순으로 운행
  - Inorder 운행 : Left - Parent - Right 순으로 운행
  - Postorder 운행 : Left - Right - Parent 순으로 운행



### 수식의 표기법

- parent를 operator, Left와 Right를 operand라고 했을 때, 셋의 표기 순서를 분류한 것이다
- 전위 운행, 중위 운행, 후위 운행과 같이 나타내며, 중위 표기법이 사람이 표기하는 방법이다.



### 기출문제 따라잡기

1. 다음 트리의 차수와 단말 노드의 수는?

   트리의 차수(degree)는 노드의 자식노드의 갯수중 가장 많은 갯수를 뜻하고, 단말 노드의 수(Terminal node = leaf node)는 자식 노드가 없는 노드의 수를 말한다

2. 트리의 구조에 대한 용어 설명 중 옳지 않은 것은?

   root 노드는 부모노드가 없으므로, 모든 노드가 부모노드를 가지는 것은 아니다

3. 다음 트리를 전위 순회 한 결과는?

   전위 순회는 부모, left, right 순으로 조회하는 것을 말한다. 

4. 다음 트리를 preorder 운행법으로 운행할 경우 가장 먼저 탐색되는 것은?

   부모부터 순회하므로 1번이 가장 먼저 탐색된다

5. 다음 트리에 대한 Inorder 운행 결과는?

   Inorder 운행은 Left - 부모 - right 순서로 운행한다.

6. 다음 Postfix 연산식에 대한 연산 결과로 옳은 것은?

   Postfix 연산식은 Postorder 운행과 같이 Left - Right - Parent 순으로 운행하며, 즉 Operand1, Operand2, Operator 순으로 표기된다. 즉 연산자 앞에 숫자 둘이 있으면 해당 숫자와 연산하면 된다

7. 다음 과 같은 중위식을 후위식으로 표현한 것은?

   중위식을 후위식으로 표현하는 방법은 우선순위가 높은 순서대로 연산 뒤로 연산자를 뒤로 빼는 것이다

8. 다음과 같이 주어진 후위 표기 방식의 수식을 중위 표기 방식으로 나타낸 것은?

   연산자 앞에 두개의 숫자가 오면, 해당 연산부터 처리할 수 잇도록 중위 표기를 하면 된다.

9. 다음의 중위식을 전위식으로 옳게 변환한 것은?

   우선순위가 높은 순서대로 연산자를 연산 앞으로 빼면 된다.

10. 아래 이진트리를 후위 순서로 운행한 결과는?

    left - right - parent 순으로 순회하면 된다





## 38. 정렬



### 삽입 정렬

- 가장 간단한 정렬 방식
- 이미 순서화된 파일에 새로운 하나의 레코드를 순서에 맞게 삽입시켜 정렬시킨다
- 평균, 최악의 경우 모두 시간 복잡도는 O(n^2)이다



### 쉘 정렬

- 삽입 정렬을 확장한 개념이다
- 매개변수의 값으로 서브 파일을 구성하고 각 서브파일을 삽입 정렬 방식으로 배열하는 방식.
- 평균 시간 복잡도는 O(n^1.5)이고, 최악의 경우 O(n^2)이다



### 선택 정렬

- n개의 레코드중에 최소값을 찾아 맨 앞에 놓고, 그다음 n-1개중 최소값을 두번째에놓고.. 하는 방식을 반복한다
- 평규과 최악 모두 수행시간 복잡도는 O(n^2)





### 버블 정렬

- 인접한 두개의 레코드 키 값을 비교하여 크기에 따라 위치를 서로 교환한다
- 계속 정렬 여부를 플래그 비트(f)로 결정한다
- 평균, 최악의 경우 모두 수행 시간 복잡도는 O(n^2) 이다





### 퀵 정렬

- 레코드의 많은 자료 이동을 없애고 하나의 파일을 부분적으로 나누어 가면서 정렬하는 방식으로, 키를 기준으로 작은 값을 왼쪽에, 큰 값을 오른쪽에 분해시키는 방식이다.
- 정렬중에 가장 빠른 방식이다
- Divide와 Conquer를 반복하면서 자료를 정렬한다
- 위치에 상관없이 임의의 키를 분할 원소로 사용할 수 있다
- 평균 수행 시간 복잡도는 O(nlogn)이고 최악의 경우에는 O(n^2)이다



### 힙 정렬

- 주어진 자료를 전이진트리(Complete Binary Tree)로 바꾼 후, 트리를 Max Heap Tree로 변환하여 정렬하고 순회를 통해서 정렬한 결과를 반환하는 것
- 평균과 최악의 경우 모두 시간 복잡도는 O(n log n)이다



### 2-way 합병 정렬(Merge Sort)

- 원소의 갯수가 1개가 될때까지 divide를 반복하고 정렬된 상태의 merge를 원래대로 하나가 될때까지 반복하여 정렬한다
- 평균과 최악의 경우 모두 시간복잡도는 O(nlogn)이다.





### 기수 정렬(Radix Sort) = Bucket Sort

- 자릿수(Digit)별 정렬하는 방식이다.
- 레코드의 키 값을 분석하여 같은 수 또는 같은 문자끼리 순서에 맞는 버켓에 분배하였다가 버킷의 순서대로 레코드를 꺼내어 정렬한다
- 평균과 최악 모두 시간 복잡도는 O(dn)이다.



### 기출문제 따라잡기

1. 다음 자료에 대하여 선택 정렬을 이용하여 오름차순으로 정렬하고자 한다. 3회전 후의 결과로 옳은 것은?

   선택정렬은 1회전 할때마다 맨 앞에서부터 한자리씩 오름차순으로 정렬되며, 최소값을 해당 위치에 배치하면서 정렬한다

2. 다음 초기 자료에 대하여 삽입 정렬을 이용하여 오름차순 정렬한 경우 1회전 후의 결과는ㅇ?

   삽입 정렬은 n회차때, n+1번째 자리를, 앞의 n자리에서 자신의 자리에 맞는 곳에 넣음으로써 정렬한다. 넣고나서 뒤의 데이터는 한칸씩 뒤로 밀린다

3. 다음 자료를 버블 정렬을 이용하여 오름차순으로 정렬할 경우 pass 2의 결과는?

   버블 정렬은 앞에서부터 2개씩 비교하여 뒤로 밀어나가며, 가장 큰 원소부터 뒤에 차곡차곡 쌓인다







