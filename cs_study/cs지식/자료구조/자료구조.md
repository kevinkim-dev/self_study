# 자료구조



### 1. 해시테이블을 구현하는 방법에 대해 설명해주세요.

- 해시 테이블에는 해시 충돌이 되도록 적게 일어나게 하는 해시 함수와, 해시 충돌 시 처리 로직이 필요합니다. 해시 충돌이 일어나지 않게 하는 hash function 알고리즘으로는 value를 테이블 크기로 나눈 나머지를 hash로 쓰는 Division Method, value를 ASCII 코드로 바꾸고 합한 데이터를 테이블의 주소로 사용하는 Digit Folding, value와 0~1사이 상수를 곱한 소수부분에 2의 상수승을 곱한 값을 hash로 사용하는 Multiplication Method, 그리고 다양한 해시함수에서 무작위 함수를 선택해서 사용하는 Universal method 가 있습니다. 해시 충돌이 일어 났을 때 처리 로직도 필요한데, 충돌한 값을 같은 index에 linkedlist로 연결한 seperate Chaning기법, 그리고 일정 기준에 따라 다음 주소로 이동해서 어떻게든 다른 주소에 저장하는 Open Addressing이 있습니다. seperate chaning에는 별다른 로직이 필요없지만, hash function에 따라 검색 속도가 O(N) 까지 느려질 수 있습니다. Open Addressing은 table 크기보다 적은 수의 data가 들어오기 전까지는 O(1)로 검색할 수 있지만, new Address를 찾기위한 과정이 오래걸릴 수 있습니다.





### 2. Array와 LinkedList의 차이점을 시간 복잡도와 연관지어 설명해주세요.

- Array와 LinkedList는 저장되는 물리적 주소의 연속성의 주된 차이점이 있습니다.
- Array는 요소들이 연속된 주소에 저장되기 때문에 Index값으로 Random Access를 지원합니다. 반면 LinkedList는 연속되지 않은 주소에 저장되기 때문에, 각 node가 value와 함께 다음 node의 위치를 가리키는 주소를 함께 가지고 있으며 이러한 특성 때문에 순서대로만 탐색할 수 있는 Sequential Access를 지원합니다.
- 조회
  - Array는 Random Access로 원하는 Index를 통해 한번에 찾을 수 있기 때문에 O(1)입니다.
  - Linked List는 Index가 없어 Sequential Access로 search하듯이 찾아야 하기 때문에 O(N)입니다.
- search
  - Array는 index 0~N-1까지 모두 찾아야하므로 최악의 경우 O(N)입니다.
  - Linked List는 조회와 같은 로직으로 O(N)입니다,
- Insert(맨 앞에)
  - Array는 모든 원소를 오른쪽으로 미는데 O(N), 삽입에 O(1)이므로 O(N)입니다.
  - Linked List는 새로운 노드를 생성하고, 노드가 LinkedList의 원래 첫번째 노드의 주소를 가리키게 하기만 하면 되므로 O(1)입니다.
- Insert(맨 뒤에)
  - Array는 맨 뒤에 삽입만 하므로 O(1)입니다.
  - Linked List는 sequential Access로 마지막 노드까지 찾아가는데 O(N), 거기서 노드를 삽입하는데 O(1)이므로 O(N)입니다.
- delete
  - Insert와 동일합니다.
- 메모리 할당
  - Array는 Compile Time에 할당하는 Static Memory Allocation이 이루어집니다. 즉 첫 할당에 충분한 길이의 Array를 선언해야하며, 해당 길이가 넘어가면 담을 수 없다는 단점이 있습니다. 이 때 메모리 할당은 Stack에 이루어집니다.
  - Linked List는 runtime에 필요할때마다 할당하는 Dynamic Memory Allocation이 이루어집니다. node가 추가 될 때마다 추가되는 node의 memory 할당을 요구하는 system call이 발생하며 길이에 제한이 없다는 장점이 있지만 잦은 system call로 시간이 지연될 수 있습니다. 메모리 할당은 heap에서 이루어집니다
- 결론
  - 시간
    - Array는 메모리 할당이 한번에 이루어져 추후 시간 지연이없고, 조회의 면에서 LinkedList보다 빠른 장점이 있습니다. 따라서 상대적으로 조회와 검색에 유리하고 삽입과 삭제에 불리합니다
    - Linked List는 길이 확장이 가능하지만 index가 없어서 삽입과 수정의 작업에서 유리하지만, 조회와 검색에서는 상대적으로 불리합니다. 다만 메모리의 할당과, 해제에서 System call이 발생해서 느려질 수 있습니다.
  - 공간
    - Array를 한번에 충분히 큰 크기로 잡는다면 시간적으로 Linked List에 비해 유리하지만, 내부 단편화가 이루어질 수 있습니다. 예를 들어 Array의 길이를 100만으로 잡았는데 실제로 들어간 데이터는 5개라고 했을 때, 조회, 탐색, 삽입, 삭제 모든 면에서 시간적으로 LinkedList에 비해 밀리지 않지만 남은 99만9995개의 공간은 Array를 해제하기 전까지는 내부 단편화가 일어나 낭비됩니다.
    - LinkedList는 공간이 필요할때, 필요하지 않을때마다 공간이 할당되거나 해제되어 메모리 사용 시 낭비가 일어나지 않습니다.





### 3. Stack으로 Queue, Queue로 Stack 구현

- Stack 2개로 Queue 구현
  - Stack에 원소를 모두 push한 경우 가장 깊숙한 원소가 출력되어야 dequeue를 구현할 수 있는데, 여분의 stack에 모든 내용을 pop해서 차례로 푸시한 후, 원래 stack이 비었을 때, 여분의 stack에서 pop을 한번 해주면 가장 깊숙히 있던 원소를 dequeue할 수 있다.
  - 여분의 stack에 원소가 남아있더라도, 다시 enqueue가 발생하면 원래 stack에 push한다. pop이 발생하면, 여분의 stack에 남는 원소가 없을 때까지 여분의 stack에서 pop하고 여분의 스택이 비었을때 pop이 들어오면 다시 원래 stack의 모든 원소를 pop해서 여분의 stack에 넣고 pop하는 과정을 반복한다.

- Queue 2개로 Stack 구현
  - Queue에 원소를 모두 그냥 enqueue한 경우 dequeue를 하다가 마지막원소임을 깨닫고 pop해주는 방법이 존재하지 않습니다. 따라서 애초에 dequeue == pop 이 되도록 구현을 해주어야 합니다.
  - 두 개의 queue 중 push는 비어있는 queue에 진행합니다. 그리고 반대 queue의 모든 원소를 dequeue해서 방금 push한 enqueue해줍니다.
  - 이렇게되면 모든 dequeue연산은 pop과 같아집니다.



### 4. 이진트리의 단점과 이를 보완한 자료구조에 대해 설명해주세요.

- 이진트리는 노드가 고르게 분포한다면 O(logN)의 빠른 탐색속도를 자랑하지만, 최악의 경우, 모든 노드가 한 방향으로 쏠리면 탐색속도는 O(N)이 됩니다. 이를 보완하기위한 구조로 Red-Black 트리와 AVL 트리가 있습니다.
- Red-Black Tree는 모든 노드가 Red혹은 Black이며, Root는 무조건 Black입니다. 이 트리는 데이터를 저장할 때 Root에서 모든 Leaf까지 경로에 포함된 Black의 갯수가 같음을 보장하도록 Tree에 저장합니다. 그 과정에서 Restructuring과 색을 바꾸는 recoloring이 발생할 수 있습니다.
- AVL Tree는 Balance Factor를 통해서 좌우 균형을 맞춥니다. Balance Factor란 좌측 서브트리와 우측 서브트리의 깊이의 차이인데, 이 차이가 2가 된다면 rotation을 통해서 균형을 맞춰줍니다.
- AVL Tree는 Rotation을 통한 시간 소요가 많이 때문에 요소의 추가와 삭제에 시간적으로 Red-Black Tree에 비해 약하지만, 좌우 밸런스가 거의 비슷하기 때문에 탐색의 시간복잡도를 O(logN)으로 보장합니다. 하지만 Red-Black Tree는 삽입과 삭제를 통한 Restructuring과 Recoloring은 비교적 수월하기 때문에, 완벽히 O(logN)을 보장하지 못하더라도 삽입과 삭제가 더 빠릅니다.



### 5. 스택과 큐에 대해 설명하고 사용되는 예시

- Stack과 Queue는 연속적인 자료구조이지만, 출력의 순서가 다르다는 차이를 가지고 있습니다.
  - Stack은 LIFO(Last In First Out)구조로, 가장 나중에 들어온 원소가 가장 먼저 출력되는 자료구조입니다. stack이 사용되는 경우는 가장 최근의 행동을 돌이켜야 할 때 사용이 되며, 대표적인 예시로는 브라우저의 뒤로가기 버튼이 있습니다. history stack에는 내가 거쳐온 페이지들이 저장되며, 해당 Stack에서 pop을 하면 가장 최근에 조회했던 페이지가 반환되므로 뒤로가기를 수행할 수 있습니다.
  - Queue는 FIFO(First In First Out)구조로, 가장 먼저 들어온 원소가 가장 먼저 출력되는 자료구조입니다. Queue가 사용되는 경우는, 작업 Queue와 같이 먼저 도착한 순서대로 일을 처리하는 경우입니다. 프로세스 스케쥴링의 FCFS구조(먼저 온 프로세스를 처리)와 데이터 패킷을 전송하는 경우 먼저 들어온 데이터 패킷이 먼저 전송됩니다.



### 6. Graph 자료구조에 대해 설명하고 구현 방법을 설명해주세요.

- 그래프 자료구조는 노드와 노드를 연결한 간선으로 이루어진 자료구조입니다. 이 자료구조를 이용하면 객체 간의 관계를 표현할 수 있습니다. 여기서 수직적인 구조를 갖게되면(사이클이 불가능, 자체 간선 불가능) 트리가 됩니다.
- 그래프 자료구조를 구현하는 방법은 크게 두가지입니다.
  - 인접리스트(Adjacency List): 인접한 노드를 해시테이블(python의 dictionary)과 같은 자료구조에 저장해서 표현하는 방법입니다. 해당 정점의 번호로 인접한 번호의 노드들로 쉽게 접근할 수 있습니다.
  - 인접 행렬(Adjacency Matrix): N개의 노드가 존재할 때, NxN 의 2차원 배열(행렬)을 통해서 인접한 노드를 표현하는 방법. 3번 node와 7번 노드가 연결되어있다면 matrix M의 M[3] [7]과 M[7] [3]이 true 혹은 1이 되고 연결되지 않은 노드 끼리는 false 혹은 0이 되는 방법으로 그래프를 표현합니다.
- 인접 리스트는 인접 행렬에 비해서 공간 복잡도가 낮고, 인접한 노드를 쉽게 찾을 수 있습니다. 하지만, 두 노드를 잇는 간선이 존재하는지 탐색할 때는, 한 노드에 있는 모든 간선의 리스트를 탐색해야하므로 간선이 많을 수록 검색 시간이 증가합니다.
- 인접 행렬은 그래프의 간선이 많이 존재하는 밀집 그래프의 경우 장점을 가집니다. 두 정점을 연결하는 간선의 존재 여부를 O(1)안에 달 수 있습니다. 하지만 N개의 node를 가진다면, 무조건 N^2의 공간이 필요하며, 어떤 노드에 인접한 전체 노드를 알고싶을때는 한 열을 모두 탐색하므로 O(N)으로 느리고, 전체 간선수를 알고 싶을 때는, 전체를 탐색해야하므로 O(N^2)시간이 필요합니다.







### 7. B+ 트리에 대해 설명하시오.

- B+ 트리는 B트리의 리프노드에 변형을 준 형태입니다. B트리는 Binary 트리와는 다르게 자식노드를 3개 이상도 가질 수 있고, 노드에 2개 이상의 키값이 포함될 수 있습니다. 또한 모든 리프노드들이 같은 레벨을 가질 수 있도록 벨런스를 맞추며, 정렬된 순서를 보장합니다. 따라서 탐색 시 키값과 대소비교를 해서, 검색하고자하는 값보다 큰 키와 작은 키 사이에 연결된 자식노드로 이동하면서 탐색하는 방향으로 빠르게 탐색을 진행할 수 있습니다.
- B+트리는 리프노드에 모든  key값이 연결 리스트 형식으로 연결되어있습니다. 즉 해당 키값이 leaf가 아닌 노드에 존재할 수도 있지만, leaf에 없는 키는 없습니다. 따라서 연속적인 탐색을 위해서 B트리는 root에서 다시 검색을 수행해야하는 반면 B+트리는 이 연결리스트를 통해서 선형 탐색이 가능하므로 빠르게 탐색을 진행할 수 있습니다.