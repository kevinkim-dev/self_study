# 이진수의 음수 표현

>  않이...  0과 1로  '-' 를 어떻게 표현해요..?



## MSB(Most Significant Bit)

> 가장 중요한 비트

- 2진수 예시를 하나 들어보겠습니다

  > 10진수 33
  > 33 = 32 + 1 = 2^5 + 2^0 = 2^5 * <u>1</u> + 2^4 * <u>0</u> + 2^3 * <u>0</u> + 2^2 * <u>0</u> + 2^1 * <u>0</u> + 2^0 * <u>1</u>
  >
  > 밑줄 친 숫자만 모으면 
  > 2진수 100001 가 만들어집니다

- 밑줄 친 비트를 보면 왼쪽으로 갈 수록 2의 지수가 1씩 증가합니다. 즉 비트의 1이나 0이냐 여부에 따라서 수의 총합에 미치는 영향이 증가한다는 것입니다.

- 2진수 100001에서 1인 비트는 2개인데, 맨 왼쪽 비트와 맨 오른쪽 비트는 같은 1인데, 왼쪽 비트는 1이냐 0이냐에 따라 32 차이가 나고, 오른쪽 비트는 1이냐 0이냐에 따라 1의 차이가 납니다.

- 이렇게 수에 영향을 가장 크게 미치는 비트, 가장 중요한 비트, 가장 왼쪽의 비트를 MSB, Most Significant Bit라고 부릅니다

- 반대로 영향을 가장 적게 미치는 비트, 가장 중요하지 않은 비트, 가장 오른쪽의 비트를 LSB, Least Significant Bit 라고 합니다

- 컴퓨터에서 수를 표현할 때, MSB가 부호를 결정하며, 1이면 음수, 0이면 양수임을 뜻합니다.
- 즉 맨 앞의 비트는 부호를, 두번째부터 끝까지 비트로 수 자체를 나타냅니다.



## 음수를 나타내는 방법



### 1. 부호 있는 절대치

- 가장 간단하게 음수를 표현하면서 <u>**사람에게 친화적인 방식**</u>으로 음수를 나타내는 방법입니다

- MSB가 0이면 양수 1이면 음수입니다.

- MSB를 제외한 비트를 통해서 양수와 음수 상관없이 동일한 방식으로 수를 만들면 됩니다.

  > 예시
  >
  > 10진수 33
  > 2진수로 표현하면 100001입니다.
  > 양수이므로 MSB에 0을 붙어줘야 하므로 '0' + '100001' = '0100001' 입니다
  >
  > 10진수 -33
  > 마찬가지로 33을 2진수로 표현하면 100001 입니다
  > 음수이므로 MSB에 1을 붙여줘야 하므로 '1' + '100001' = '1100001' 입니다

- n개의 비트가 있다면 1개는 MSB로 부호 비트이고 n-1개의 비트로 수를 표현합니다. 따라서 0과 함께, 양수는 2^(n-1)-1, 음수는 -(2^(n-1)-1) 까지 표현 가능합니다.

- 장 / 단점

  - 장점

    사람 친화적이어서 이해하기 쉽고, 사람이 읽기, 변환하기 쉽습니다

  - 단점

    0을 표시하는 방법이 두가지입니다. 4비트 수라고 하면 0000, 1000 모두 0을 뜻합니다. 즉 +0과 -0을 모두 표시하기 때문에 혼란이 생길 수 있습니다

    컴퓨터의 주 기능은 연산인데, 부호 있는 절대치는 음수가 포함된 연산이 불가능합니다.

    > 1 + (-1) = 0  (10진수 연산)
    >
    > 0001 + 1001 = 1010 (부호 있는 절대치의 연산)
    > 1  + (-1) = (-2) 라는 결과가 나옵니다.

```
컴퓨터에서 사용하지 않습니다
```



## 2. 1의 보수(1's Complement)

- 음수를 표현하기 위해서 양수에 not(~) 비트연산을 하는 방법입니다

- 모든 비트를 반전시킵니다. 0 -> 1, 1 -> 0

  > 예시
  >
  > 10진수 33
  > 2진수로 표현하면 100001입니다.
  > 양수이므로 MSB에 0을 붙어줘야 하므로 '0' + '100001' = '0100001' 입니다
  >
  > 10진수 -33
  > 33을 2진수로 표현하면 100001 입니다
  > 모든 비트를 반전시키면 '011110' 입니다
  > 음수이므로 MSB 로 1을 추가해 줍니다. '1' + '011110' = '1011110'

- n개의 비트가 있다면 1개는 MSB로 부호 비트이고, n-1개의 비트로 수를 표현하되, 음수의 경우에는 비트를 뒤집어서 반전시켜야지 수를 얻을 수 있습니다.

  > 1011110 을 다시 10진수로 바꾸기 위해서는 MSB를 제외한 n-1개 비트를 반전시킵니다
  > 011110  -> 100001 -> 33
  >
  > MSB가 1이었으므로 이 수는 음수입니다. 따라서 -33 이 됩니다

- 마찬가지로 n-1개의 비트로 표현을 하므로 양수는 2^(n-1)-1, 음수는 -(2^(n-1)-1) 까지 표현 가능합니다

- 장 / 단점

  - 장점

    2의 보수에 비해서 1의 보수를 만들기 쉽습니다. 비트 반전만 시키면 되기 때문!

  - 단점

    부호 있는 절대치와 같이 0이 두개입니다.

    > +0 
    > 0000
    >
    > 그러면 1111은..?
    > MSB인 1을 뺀 111을 부호 반전시키면 000입니다. 
    > 000은 0이고, MSB가 1이었기 때문에 -0 이 만들어집니다.

    연산이 가능하지만 과정이 조금 복잡합니다

    > 5 + (-1) 을 계산해 보겠습니다
    >
    > 10진수 5 
    > -> 2진수 0101
    >
    > 10진수 -1
    > -> 1 이 0001 이므로 비트 반전시키면 1110
    >
    >   0101
    > +1110
    > ㅡㅡㅡ
    > 10011  
    >
    > 이런... 4-bit였는데 5-bit가 되어버렸습니다.
    >
    > 이런 경우 carry가 발생했다고 하며 ('1'0011) 잉여로 올림으로 발생한 비트를 carry bit 라고 부릅니다
    >
    > 1의 보수의 연산은 이 carry를 원래 수에 더해주어야 합니다
    >
    > '10011' -> '1' + '0011' -> '0100' = 4
    >
    > 이렇게 carry를 더해주고 나서야 5 + (-1) 의 결과인 4가 제대로 출력되었습니다.





## 3. 2의 보수(2's Complement)

- 1의 보수를 구한 후 1을 더해주는 방법입니다.

- 즉 모든 비트를 반전시킨 후 + 1 을 해줍니다

  > 예시
  >
  > 10진수 33
  > 2진수로 표현하면 100001입니다.
  > 양수이므로 MSB에 0을 붙어줘야 하므로 '0' + '100001' = '0100001' 입니다
  >
  > 10진수 -33
  > 33을 2진수로 표현하면 100001 입니다
  > 모든 비트를 반전시키면 '011110' 입니다.
  > 음수이므로 MSB로 1을 추가해줍니다 '1' + '011110' = '1011110'
  >
  > 여기에 1을 더합니다. '1011110' + '0000001' = '1011111'

- 2진수에서 다시 10진수로 바꾸기 위해서는 이 과정을 반대로 해야 합니다. 
  비트 반전 후 1을 더해줬었으므로, 반대로 1을 먼저 빼고 비트 반전을 시켜줍니다

  > 예시
  >
  > 2진수 '1011111'
  > MSB를 분리시킵니다 '1011111' -> '1', '011111'
  >
  > 1을 뺍니다 '011111' - '000001' = '011110'
  > 반전시킵니다 '011110' -> '100001'
  >
  > '100001'은 33이고, MSB 가 1이었으므로 -33입니다.

- 1의 보수와는 달리 0이 두개가 아닙니다

  > 2진수 1111
  >
  > MSB 1을 분리시킵니다 '1111' -> '1', '111'
  > 1을 뺍니다 '111' - '001' = '110'
  > 반전시킵니다 '110' -> '001' 
  >
  > '001'은 1이고 MSB가 1이었으므로 -1입니다
  >
  > 1의 보수에서는 1111이 -0이었지만 2의 보수에서는 -1이 되었습니다

- -0이 없기 때문에 음수를 1개 더 표현할 수 있습니다

  > 2진수 1000
  >
  > 2의 보수에서 예외인 수입니다. 2의 보수 연산을 해도 그대로 1000이 나옵니다.
  >
  > MSB가 1이고, 나머지 n-1개의 비트가 0인 경우 이 수는 -2^(n-1)을 뜻합니다.
  >
  > 1의 보수나 부호있는 절대치와는 달리 -0이 없기 때문에 음수에서 하나를 더 표기할 수 있게 되어서 생긴 예외입니다

- 표현범위는 0, 양수는 2^(n-1)-1까지, 음수는 -2^(n-1) 까지 표현 가능합니다.

  > 4개 비트인 경우
  >
  > 부호있는 절대치: -7 ~ 7까지 표기 가능, 0이 두개
  >
  > 1의 보수: -7 ~ 7 까지 표기 가능, 0이 두개
  >
  > 2의 보수: -8 ~ 7 까지 표기 가능, 0은 1개

- 장 / 단점

  - 장점

    1의 보수에 비해 연산이 간단합니다. carry 발생시 버립니다.

    > 5 + (-1) 을 계산해 보겠습니다
    >
    > 10진수 5 
    > -> 2진수 0101
    >
    > 10진수 -1
    > -> 1 이 0001 이므로 비트 반전시키면 1110, 1을 더해야 하므로 '1110' + '0001' = '1111'
    >
    >   0101
    > +1111
    > ㅡㅡㅡ
    > 10100  
    >
    > 역시 carry가 발생했습니다.
    >
    > 1의 보수 연산과는 달리, 2의 보수 연산의 경우 그냥 carry를 버려주면 됩니다.
    >
    > '10100' -> '0100'  = 4
    >
    > 5 + (-1) 의 결과인 4가 제대로 출력되었습니다.

    0이 한개 뿐이므로 혼란이 생기지 않습니다

  - 단점

    1의 보수에 비해서 음수 만들기가 복잡합니다





## 부록. Overflow와 Carry

> SWEA에서 Run 돌리면 숟하게 만나게 되는 Stack Overflow... 에서 Overflow가 무엇일까요?

- overflow: 넘치다, 범람, 넘쳐 흐름

- 2진수 연산을 했을 때, 수의 범위가 표현이 불가능해지는 경우 overflow가 발생합니다.

  > 4-bit 수라면 -8 ~ 7 까지 표현이 가능합니다
  >
  > 5 + 4 = 9 입니다. 9는 4-bit 수로 표현이 불가능합니다.
  >
  > 10진수 5 -> 2진수 0101
  > 10진수 4 -> 2진수 0100
  >
  > 덧셈 ㅡㅡㅡㅡㅡㅡㅡㅡ
  >               9                1001
  >
  > 덧셈 결과가 1001이 되었습니다. 
  > 1001 은 9가 아닌가? 할 수 있지만, 사실 맨앞의 1은 8이 아니라 MSB로 부호비트이기 때문에 -7이 되어버립니다.
  >
  > 즉 해당 n개의 bit로 표현 불가능한 범위로 연산을 진행하면 overflow가 발생했다고 하며 연산결과에 문제가 생깁니다.

- 2진수 연산을 했을 때, n+1 번째 bit가 생기는 경우 carry가 발생했다고 합니다.

  > 10진수 5 
  > -> 2진수 0101
  >
  > 10진수 -1
  > -> 1 이 0001 이므로 비트 반전시키면 1110
  >
  >   0101
  > +1110
  > ㅡㅡㅡ
  > 10011  
  >
  > 이 경우 4 bit 엿는데 5 bit 수가 되었으므로 n+1번째 bit가 발생했으므로 carry가 발생했다고 합니다.

```
n-bit 2의 보수의 경우
n+1 번째 bit가 생겼다 -> carry가 발생했다. -> 문제 없음
n 번째 bit(MSB)에 문제가 생겼다 -> overflow가 발생했다 -> 표현 가능한 값의 범위를 넘어섰음 -> 문제
```

