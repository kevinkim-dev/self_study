# 컴퓨터 구조





### 1. 캐시메모리에 대해서 설명해주세요



- 일반적으로 저장공간은 크면 클수록 속도가 느려지고, 크기가 작을 수록 속도가 빨라지는데, CPU의 레지스터는 속도가 빠른 반면 공간이 작고, 보통의 저장공간은 크기가 큰 반면 속도가 느립니다. 그 사이의 간극을 줄이기 위해 적당한 속도와 적당한 크기를 가진 메모리가 중간단계에서 중재를 맡고 있는데 이것을 캐시메모리라고 합니다.

- 어떤 데이터가 필요할 때 먼저 캐시를 훑어 해당 정보가 있는지 확인합니다. 이 때 정보가 캐시에 있다면 메인 메모리까지 가지 않고 빠르게 캐시에서 정보를 불러올 수 있으며, 이 것을 cache hit이라고 합니다. 캐시에 없다면 메인메모리까지 가서 가져오는 느린 과정을 겪는데, 이것을 cache miss라고 하며, 전체 데이터 접근 횟수에서 cache hit의 비율인 hit ratio를 최고로 높일 수 있는 저장 전략이 필요합니다.

- 캐시에서 읽기 뿐만 아니라 쓰기 작업을 수행 할 때 두가지 방법이 있습니다

  - Write Through: 캐시에 해당 데이터와, 메모리의 데이터에 모두 쓰는 방법입니다. 설계구조가 간단하지만, 결국 메인 메모리에 접근해야하므로 상대적으로 느립니다.

  - Write Back: 캐시에만 해당 데이터를 쓰는 방식입니다. 캐시에 해당 블록이 남아있는 동안에는 메인 메모리에서 조회하지 않고 캐시에서 조회하므로, 굳이 메모리에 접근하지 않아도 되기 때문에 사용하는 방법으로 속도가 빠릅니다. 다만, cache에 새로운 블럭을 가져와야 할 때, 메모리에 변경 사항이 기록되지 않은블럭이 지워져야 한다면 해당 블럭을 메모리에 덮어씌우는 추가 로직이 필요합니다

- 캐시는 시간적 지역성과 공간적 지역성을 따르는데, 짧은 시간 텀 내에 또 조회될 가능성이 높다는 시간적 지역성에 따라 cache miss로 인해 메인메모리에서 한번 참조된 데이터 블록은 cache memory에 저장됩니다. 하지만 cache memory는 거의 항상 꽉 차 있으므로, 이 경우마다 다른 블럭을 삭제해야하는데, 이것을 캐시 메모리 교체라고 하며, 효율적인 교체를 위한 여러 알고리즘이 존재합니다

  - random: 임의로 교체될 페이지를 선정하며, 가장 간단한 로직을 가지고 있어 오버헤드가 적습니다.
  - FIFO: cache에 들어온지 가장 오래된 페이지를 교체합니다. 로직이 간단하지만, 가장 최근에 조회된 페이지더라도 가장 먼저 cache에 들어온 페이지라면 교체될 수 있습니다.
  - LFU: 사용횟수가 가장 적은 페이지를 교체. 합리적 변경으로 보이지만, 이것 역시 가장 최근에 조회된 페이지가 교체될 가능성이 있습니다.
  - LRU: 가장 오랫동안 사용되지 않은 페이지를 교체합니다.
  - NRU: 가장 오랫동안 사용되지 않은 페이지를 교체합니다. LRU와는 다르게, 참조와 수정으로 나누어 4가지 우선순위에 따라 교체됩니다.(참조되고 수정된, 참조됐지만 수정되지 않은, 참조되지 않았지만 수정된, 참조되지도 않고 수정되지도 않은 의 순서의 우선순위를 가집니다.)

  - MFU: 가장 참조횟수가 많은 페이지를 교체 (이미 많이 사용했으므로 사용하지 않을 것이라는 논리를 가진 페이지 교체)





### 2. call by value, call by address, call by reference 차이

- call by value와 address는 C언어에 있던 개념이며, call by reference 는 call by address를 대체하는, C++에서 생긴 개념입니다.
- call by value는 메모리에서 변수의 값 자체를 복사하는 개념입니다. 따라서 복사한 값을 변화해도 원본 값은 바뀌지 않습니다.
- call by address는 변수의 주소값을 복사해와서 할당하는 개념입니다. 즉 해당 변수값의 주소의 값을 변화시킨다면 원본 값을 바꿀 수 있습니다.
- call by reference는 call by address와 동일하게 해당 변수 원본값을 변화시키지만, 주소 대신 레퍼런스 값을(?) 할당합니다. 따라서 call by address는 고정 4byte를 사용하는 반면 메모리 사용을 줄일 수 있습니다.

