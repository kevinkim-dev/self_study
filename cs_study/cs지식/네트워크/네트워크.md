# 네트워크



### 1. TCP와 UDP에 대해 자세히 설명하시오.

- TCP와 UDP는 OSI 7계층 중 4계층인 Transport 계층에 속한 데이터 전송 프로토콜입니다.
- TCP와 UDP는 수신할 때까지의 과정이 책임져지는가 마는가의 차이가 있습니다. TCP는 정보를 보내고 나면 흐름 제어 및 혼잡 제어를 통해서 데이터의 순서를 보장하고 제대로 수신했는지 유무를 통신하면서 높은 신뢰성을 보장합니다. 이 때 신뢰성 있는 통신을 보장하기 위한 검증과정으로 통신을 열때는 3-way handshaking을, 닫을때는 4-way handshaking을 사용합니다. 신뢰성 있는 통신을 할 수 있지만, 속도가 느리다는 단점이 있습니다. 따라서 정확성이 보장되어야하는 텍스트 혹은 파일을 전송할 때 사용합니다.
- UDP는 흐름 및 혼잡제어도 수행하지 않고, 데이터 수신 시의 최소한의 데이터 검증만 거치기 때문에 신뢰성이 낮은 데이터 전송 프로토콜입니다. TCP 의 handshaking과 같은 연결 검증도 하지 않습니다. 대신 속도가 빠르기 때문에 비교적 낮은 정확도에 빠른 전송속도를 요구하는 음성/동영상 스트리밍에 사용합니다.



### 2. OSI 7계층에 대해 설명해주세요.

- OSI 7계층은 유지보수가 편하게 하고, 한 과정에서 오류가 생겨도 다른 과정에 영향을 미치지 않게 하기 위해 통신이 이러나는 단계를 7단계를 독립시킨 것입니다. 송신자는 7계층에서부터 1계층을 차례로 거치며, 각 계층별 규칙에 따라 encapsulate 하고 수신자는 1계층부터 7계층을 거치며, 수신자가 감싸놓은 헤더를 벗겨가면서 decapsulate과정을 수행하여 data를 수신합니다.
- 1계층(물리계층): 0과 1의 데이터를 전기적 신호로 바꾸어 전송하기 위한 물리적 전송 매체 입니다.
- 2계층(데이터링크 계층): 데이터의 흐름과 오류를 검출하여 데이터 전송의 신뢰성을 갖출 수 있도록 합니다.
- 3계층(네트워크 계층): 데이터가 송신자로부터 수신자까지 안전하고 빠르게 도착할 수 있는 라우팅 기능을 수행합니다.
- 4계층(전송 계층): 송신자와 수신자가 포트를 열고 신뢰성 있게 연결될 수 있는 과정을 수행합니다.
- 5계층(세션 계층): 통신을 하기위한 세션을 열고 닫는 기능을 통해서 연결의 맺고 끊음을 관리합니다.
- 6계층(표현 계층): 데이터를 응용계층에서 사용자에게 보여주기 쉽게 변환하거나, 세션계층을 통해서 전송되기 쉬운 형태로 변환하는 작업을 진행합니다.
- 7계층(응용 계층): 데이터를 통해 사용자와 소통하는 응용 프로그램이 통신을 하기위해 필요한 것을 제공합니다. HTTP, FTP, SNTP등의 프로토콜들이 7계층에 속합니다.



### 3. 브라우저 주소 창에 https://www.naver.com을 쳤을 때 동작 과정에 대해 설명해주세요.

- https://www.naver.com 를 입력하면 DNS서버로 가서 해당 도메인 네임에 해당하는 IP주소를 찾아옵니다. 해당 IP주소로 HTTP 요청 메시지를 보내게 되며, TCP 연결 과정을 거쳐서 클라이언트와 서버가 연결됩니다. HTTP요청 메시지를 해석해서 서버에서 해당 URI에 대한 자원을 response에 담아서 응답메시지를 보내게 되며 다시 TCP 프로토콜을 거쳐서 클라이언트에게 돌아옵니다. 

- HTML문서를 클라이언트가 받으면 사용자에게 보여주기 위해 브라우저 랜더링 과정을 수행합니다. HTML Parser를 통해서 DOM Tree를 생성합니다. 도중 CSS링크를 만나면 CSS Parser로 CSS Style Sheet를 해석해서 CSSOM을 만듭니다. DOM Tree와 CSSOM을 합쳐서 Render Tree를 만듭니다. Render Tree의 노드의 위치와 z-index를 통해 어디에 위치할 지 계산하고 그려주면서 비로소 유저가 www.naver.com을 볼 수 있습니다.





### 4. HTTP와 HTTPS의 차이에 대해서 설명해주세요

- HTTP와 HTTPS는 HyperText Transfer Protocol에 Secure이 붙었는지 안 붙었는지로 S의 차이가 납니다.
- HTTP 프로토콜은 클라이언트의 요청에 대한 서버의 응답 자원이 암호화 없이 그대로 전송됩니다. 이 때문에 속도는 빠르지만, 보안에 취약합니다.
- HTTPS는 이점을 보안하기 위해 HTTP에 보안을 추가한 것이며 SSL 인증서를 사용합니다.
  - 암호화는 공개키 암호화 방식을 사용한다.
    - 공개키 암호화 방식에는 공개키와 개인키가 있는데, 개인키는 본인만 지니고 있고, 공개키는 모두가 볼 수 있습니다. 내가 메시지를 전송할 때는 개인키로 암호화 한 후 상대방이 공개키로 복호화할 수 있고, 상대방이 메시지를 전송할 때는 공개키로 암호화 한 메시지를 보내고, 나는 개인키로 복호화해서 내용을 볼 수 있습니다.
    - 공개키로 암호화 한 메시지는 개인 키로만 복호화 할 수 있고, 개인 키로 암오화한 메시지는 공개키로만 복호화 할 수 있기 때문에 보안이 유지됩니다.



### 5. HTTP1.1와 HTTP2.0 차이점은 무엇인가요?

- HTTP1.1 과 HTTP2.0의 차이점은 동기처리와 비동기 처리의 차이로 볼 수 잇습니다
- 1.1은 송신자와 수신자 사이에서 한개의 connection당 한개의 요청만 처리가 가능합니다. 따라서 두개의 요청이 필요한 경우 먼저 수행되는 요청이 완료되어야지 다음 요청이 수행됩니다. 또한, 한번의 요청이 수행되면 connection이 닫혔다가 다시 열리므로, 매 요청마다 handshaking이 일어나서 Round Trip Time이 증가하고 네트워크 지연을 초래합니다. 또한 header에 많은 메타정보를 저장하여 header가 무거워집니다.
- 2.0은 1.1의 connection이 요청마다 죽는 것과, 한 요청이 처리되어야 다음 요청이 처리되는 것을 개선했습니다. 즉 요청 순서와 시간에 상관없이 모두 응답을 받을 수 있으며 중간에 연결이 끊어지지 않습니다. 또한 server push 기능이 생겨서 클라이언트의 요청이 아닌 것도 같이 push해서 보내줄 수 있습니다. 또한 헤더가 커지는 문제도 Header Table을 이용한 압축 기법으로 해결했는데, 중복된 Header line이 검출되면 해당 header line이 존재하는 Header Table의 index를 보내줘서 Header의 크기가 작아집니다.





### 6. RESTful API의 개념에 대해 설명해주세요.

- Representational State Transfer API의 줄임말로URI를 통해서 이름을 통해 자원을 명시하고, Method를 통해서 해당 자원에 대한 CRUD 작업을 수행하는 것입니다. 
- REST한 API개발의 아키텍쳐 원칙 세트로 클라이언트, 서버, 리소스로 구성이 되고, HTTP 프로토콜을 따르는 클라이언트-서버 아키텍쳐에서 작동합니다.Stateless 커뮤니케이션으로 한번 통신이 완료되면 서로의 상태를 저장하지 않으며 대신 캐시가능 데이터가 존재합니다. JSON, HTML, XLT 등의 형식으로 리소스를 클라이언트에 전달합니다.
- 장점
  - HTTP를 그대로 사용해서 별도 인프라 없이 사용이 쉽습니다
  - HTTP를 따르는 모든 플렛폼에서 사용 가능합니다
  - RESTful한 API로 전송을 보내면 리소스가 하나로 단정지어져서 의도하는 바를 쉽게 파악할 수 있습니다
  - 서버와 클라이언트를 독립적이게 만듭니다
- 단점
  - 표준이 없습니다
  - 사용 가능 메서드가 4개 뿐 (GET, POST, PUT, DELETE)
  - Header값을 고치는 것은 어렵습니다
  - 구형 브라우져에서는 PUT, DELETE를 제공하지 않습니다



### 7. 로드 밸런싱에 대해 설명해주세요.

- 오늘 날 서버가 처리해야 하는 일이 매우 크기 때문에, 서버의 크기를 키우는 scale up, 서버를 여러개를 증설하는 scale-out의 방식으로 서버의 과부하를 처리하고 있습니다. 그 중 scale-out 방식으로 서버를 여러개 증설하는 경우, 요청이 여러개의 서버중 어떤 서버로 갈 지 분산시키는 기술이 바로 로드 밸런싱입니다.
- 로드 밸런싱 알고리즘엔 다양한 종류가 있습니다.
  - 라운드 로빈 방식은 순서대로 돌아가면서 배정하는 방식으로, 여러 대의 서버가 동일한 스펙을 갖고 있고, 연결이 오래 지속되지 않는 경우 적합합니다.
  - 가중 라운드로빈 방식은, 서버마다 가중치가 높은 클라이언트에 우선적으로 배분하는 방식인데, 이 경우 서버끼리 트래픽 처리 능력이 다른 경우 더 처리능력이 높은 서버에 많이 배분하면서 밸런싱을 진행합니다.
  - IP 해시 방식은 요청자의 IP주소를 해싱 함수를 통해서 특정 서버로 매핑하는 방식으로, 클라이언트는 항상 같은 서버로 연결됩니다.
  - 최소 연결 방식: 요청이 들어온 시점 가장 연결상태가 적은 서버에 트래픽을 배분하는 방식입니다.





### 8. IP주소와 MAC 주소에 대해서 설명해주세요

- MAC주소는 통신이 가능한 모든 기기에 붙여지는 식별번호를 말합니다. 통신기기에는 NIC(Network Interface Controller)가 있고, 이 NIC의 제조사와 제조번호를 나타내는 것이 MAC주소입니다. 따라서 제조 시 한번 붙은 MAC주소는 변하지 않습니다. MAC주소는 콜론(:)으로 분리된 16진법 12자리로 구성됩니다. 해당 주소가 변하지 않기 때문에 broadcast통신에서 해당 기기를 찾을 때 사용할 수 있습니다. OSI 2계층의 스위치, 라우터 등이 말단 노드를 찾을 때 사용됩니다.
- IP주소는 IPv4 체계 기준으로 점으로 4개의 수로 분리된 16진법 8자리로 구성됩니다. IP주소는 인터넷 서비스 공급자(ISP)에 의해 할당되는 주소이며, 해당 주소를 통해 라우팅해서 통신기기를 찾아갈 수 있습니다. ISP에 의해 할당되는 주소라는 성격에 따라, 주소가 바뀔 수도 있습니다. 네트워크 개층에서 라우터가 통신을 위한 라우팅을 진행할 때 사용되는 주소입니다.





### 9. 쿠키와 세션에 대해 설명하시오

- HTTP 프로토콜은 비연결지향이기 때문에, 연결을 한번 하면 서로에 대한 상태를 저장하지 않습니다. 따라서 한번 통신을 하고나면 인증을 포함한 모든 정보가 날아가기 때문에, 중요한 정보를 저장하고 유지하여 통신하기 위해서 쿠키와 세션을 사용합니다.
- 쿠키와 세션의 가장 큰 차이점은 이 정보를 어디에 저장하는가 입니다. 결론부터 말하자면 쿠키는 클라이언트에서, 세션은 서버에서 저장하는 것입니다.
- 쿠키는 클라이언트에서 key-value형식으로 데이터를 저장하며, HTTP통신을 할 때, 서버가 생성하여 클라이언트에게 전해주고, 클라이언트는 통신을 할 때마다 이 쿠키를 헤더에 포함하여 전송됩니다. 이 쿠키에 들어있는 데이터를 통해서 비연결주의인 HTTP에서 인증정보를 유지한다거나, 장바구니 등 정보들을 저장할 수 있습니다.
- 세션은 서버의 세션저장소에 정보를 저장하는 것을 말합니다. 세션을 사용할 때도 쿠키를 사용하게 되는데, 한 유저가 서버에 요청을 보낼 시 세션저장소에는 해당 유저에 할당되는 공간이 생기며, 그 공간에 접속할 수 있는 열쇠가 되는 세션 ID를 쿠키에 담아서 응답을 보냅니다. 그 후 유저는 해당 쿠키를 가지고 요청을 보내면서 세션 저장소에 자신에게 할당된 세션 ID에 담긴 데이터를 가지고 통신할 수 있습니다.