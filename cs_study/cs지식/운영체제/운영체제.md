# 운영체제



###  1. 교착상태(Deadlock)의 4가지 조건에 대해 말씀해주세요.

- 데드락의 조건으로는 4가지가 있습니다
  - 상호 배제(Mutual Exclusion): 어떤 프로세스가 점유하고 있는 자원은 다른 프로세스가 쓸 수 없다, 즉 자원은 1인용이어야 합니다.
  - 점유 대기(Hold and Wait): 어떤 프로세스는 한 개 이상의 자원을 소유(Hold)한 상태에서 다른 자원을 필요(Wait)로 합니다. 만약 모든 프로세스가 한가지 자원만으로 모든 일을 해결할 수 있다면, 해당 프로세스가 끝나면 자연스럽게 다른 프로세스가 자원을 가져갈 수 있습니다.
  - 비선점(No Preemption): 한 프로세스가 자원을 점유하기 시작했다면 해당 자원을 다 쓸때까지, 점유를 스스로 해제하거나, 남이 해제할 수 없습니다. 프로세스가 다른 프로세스에게 잠깐 쓰라고 넘겨줬다가 다시 받아오는 일은 없습니다.
  - 순환 대기(Circular Wait): 프로세스들이 각각 점유한 자원과 점유하고자 하는 자원이 꼬리를 물고 물어 원래 프로세스에게 돌아와서 루프가 형성되어야 합니다. A, B의 두개의 프로세스가 있다면, A는 B가 점유한 자원을, B는 A가 점유한 자원을 요구해야 Circular Wait이 형성됩니다.



### 2. 프로세스와 쓰레드에 대해 설명해주세요.

- 프로세스는 컴퓨터에서 실행중인 프로그램을 뜻합니다. 쓰레드는 프로세스가 최소 1개를 갖고있는 프로세스의 작업 단위입니다.
- 프로세스 끼리는 Stack, Heap, Data, Code중 그 어떤 것도 공유하지 않습니다. 하지만 쓰레드끼리는 Code, Data, Heap을 공유하고 개별적인 Stack만을 가지고 있습니다.
- 프로세스끼리 어떤 것도 공유하지 않기 때문에 소통을 위해서는 Inter Process Communication이 필요하며, Context Switching에 쓰레드에 비해 상대적으로 많은 자원을 소모합니다.
- 쓰레드 끼리는 공유된 Heap을 통해서 변화를 바로 확인할 수 있으며, context switching으로 인한 오버헤드가 적지만, 자원이 공유되는 만큼 한 쓰레드의 잘못으로 모든 쓰레드가 망가질 수 있으며, 자원의 점유에 대한 복잡한 로직이 필요합니다.





### 3. 프로세스 스케쥴링에 대해서 설명해주세요

- 프로세스 스케쥴링은 제한된 갯수의 CPU로 다량의 프로세스를 효율적으로 처리하기 위한 로직입니다.
- 프로세스 스케줄링은 크게 선점형인가 비선점형인가로 두가지로 나눌 수 있습니다. 
  - 비선점형 스케쥴링: 현재 처리중인 프로세스보다 우선 순위가 높은 프로세스가 들어와도 중단하지 않고 그대로 수행한다.
    - FCFS(First Come First Served): Queue와 같은 구조로 먼저 ready state가 된 프로세스부터 수행합니다. 이런 경우 중요한 프로세스가 빠르게 수행되지 않을 수 있습니다. 따라서 Priority가 등장했습니다.
      - High Priority: 키보드 키입력 읽기, 마우스 움직임 읽기 등
      - Mid Priority: focus가 맞춰진 윈도우
      - Low Priority: focus가 없는 윈도우, Network message 등
    - SJF(Shortest Job First): 비선점형 방식의 SRTF입니다. (하단 참조)
  - 선점형 스케쥴링: 현재 처리중인 프로세스보다 우선순위가 높은 프로세스가 들어오면 해당 프로세스 수행을 중지하고, 우선순위가 높은 프로세스부터 수행합니다. 
    - Priority Scheduling: 항상 높은 Priority를 가진 프로세스부터 수행하는 스케쥴링 기법. priority가 낮은 프로세스는 계속 밀리면서 영원히 수행되지 않는 Starvation이 발생합니다. 이 starvation을 해결하기 위해 age 개념이 등장했습니다.
    - Real-Time Scheduling(Guaranteed Scheduling): 모든 Real-Time 프로세스는 최대 대기 시간(Maximum Waiting Time)을 가지고, 해당 Maximum waiting Time을 넘어서는 age를 가지면 해당 프로세스가 선택되어 수행된다.
    - SRTF(Short Remaining Time First): 수행하는데 걸리는 시간이 짧은 프로세스부터 수행합니다. 해당 프로세스가 수행되기까지의 시간은 과거까지 수행시간과 직전 수행시간의 평균으로 구합니다. starvation이 발생할 수 있습니다.
    - HRRN(Higher Response Ratio Next): SRTF에 Aging을 합친 스케쥴링입니다. (age + 수행시간)/수행시간 으로 priority를 결정하며, 수행시간이 긴 프로세스도 age가 증가함에 따라 priority가 증가하므로 starvation을 해결할 수 있습니다.
    - Round Robin(순환 할당 스케쥴링): 지정된 단위시간(time quantum)이 지나면 프로세스가 전부 실행되지 않았더라도 수행중 프로세스를 대기큐 맨 뒤로 보내고 다음 프로세스를 수행합니다. time quantum이 너무 작으면 waiting time이 줄지만 context switching 시간이 증가합니다. 반대로 너무 크면 FCFS와 다를바가 없어집니다. 따라서 적절한 크기의 time quantum을 설정해야합니다. (CPU Burst의 80퍼센트를 포함하도록 하라고 함)
    - Multi-level queues: priority에 따라 그룹을 나눠 프로세스를 분류하고, 높은 priority의 프로세스그룹을 모두 수행해야 다음 priority 그룹의 프로세스를 수행할 수 있습니다. 



### 4. 메모리 단편화와 해결 기법에 대해 설명해주세요.

- 메모리 단편화(Fragmentation)이 발생하면 메모리를 효율적으로 사용할 수 없게 되는데, 이 메모리 단편화는 외부 단편화와 내부 단편화의 두가지 종류가 있습니다. 내부와 외부의 차이는, 이미 할당된 메모리공간 밖에서 낭비가 이루어졌는지, 안에서 이루어졌는지에서 나옵니다.
  - 외부 단편화: 연속적인 데이터 할당이 필요한 순간, 이미 할당된 메모리 사이사이 남은 공간들의 합은 필요한 메모리 크기보다 충분히 크지만, 갈라져 있어서 저장할 수 없는 상황을 말합니다. 예를 들어 전체 크기가 110인 메모리에 크기가 30인 데이터가 주소 0번, 40번, 80번에 저장되었다고 하겠습니다. 그렇다면 30~39, 70~79로 총 20의 데이터 주소가 남아있습니다. 하지만 여기에 크기가 15인 데이터를 저장하려고 하면, 두 공간이 모두 10밖에 안되기 때문에 저장이 불가능합니다. 
    - 이를 해결하기 위해서 고정 길이 메모리 할당방식(paging)을 사용합니다. 미리 데이터 블럭을 일정 크기만큼 잘라놓고, 블럭 단위로 할당하는 방식입니다. 
  - 내부 단편화: 고정 길이 메모리 할당방식을 사용한 경우 발생하는 단편화 입니다. 모든 블럭을 30크기의 주소만큼 잘라 놓은 경우, 크기가 1, 2인 데이터를 저장하는데에도 크기 30짜리 블럭이 할당되므로, 각각 29, 28의 크기가 사용되지 않고 낭비되는데, 이것을 내부 단편화라고 부릅니다.
    - 이를 해결하기 위해 가변 길이 메모리 할당방식(Segmentation)을 사용합니다. 하지만 이 방법은 외부 단편화를 다시 발생시킵니다.
  - OS에서는 고정 길이 메모리 할당방식을 주로 사용합니다. 내부 단편화 비용이 더 적게 든다고 판단했기 때문입니다



### 5. 뮤텍스와 세마포어에 대해 설명해주세요.

- Mutex와 Semaphore는 공유 메모리를 접근해서 write를 할때, 같은 자원에 동시에 접근한 프로세스가 순서에 따라 결과값이 달라지는, race Condition을 해결하기 위한 방법입니다.
- Mutex는 Mutual Exclusion으로 상호배제라고 합니다. Locking과 Unlocking을 이용해서 한 리소스에 대한 접근만을 허용합니다. 즉 해당 리소스를 사용하고 있는 프로세스만이 mutex를 해제하고 다른 프로세스가 사용하도록 넘겨줄 수 있습니다.
- Semaphore는 세마포어 내부의 카운팅 변수만 큼 프로세스가 접근할 수 있으며, 한 프로세스가 접근하면 카운팅 변수가 1 감소합니다. 해당 프로세스가 사용을 마치면 다시 1이 증가하고, 카운팅 변수가 0이면 다른 프로세스가 더이상 접근할 수 없습니다. 따라서 마지막으로 들어온 (카운팅변수를 1->0으로만든) 프로세스가 락을 걸지만, 원래 이용 중이던 다른 프로세스가 락을 해제할 수 있다는 차이점이 있습니다. 카운팅변수가 1인 이진 세마포어는 뮤텍스와 동일하게 작동합니다.





### 6. fork와 exec에 대해서 설명해주세요.

- fork와 exec 모두 한 프로세스가 다른 프로세스를 실행시키기 위해 사용합니다.
- fork는 새로운 프로세스를 위한 메모리를 할당합니다. 즉 새로운 Process ID를 가진 프로세스가 새로 생성되는 것입니다. 원래 프로세스를 부모 프로세스라고 하고, 새롭게 생성된 프로세스를 자식 프로세스라고 하며 부모 프로세스의 내용을 자식 프로세스에 copy합니다. 따로 프로세스를 생성하는 것이기 때문에 부모 프로세스는 별개로 살아있습니다. fork는 프로세스의 생성 속도가 빠르고, 추가 자원 없이 자식 프로세스에 자원을 상속시킬 수 있으며, 시스템 관리를 효율적으로 할 수 있습니다.
- exec는 부모 프로세스를 덮어 씌우면서 새로운 자식 프로세스를 만드는 것입니다. 별도의 공간이 필요하지 않으며, Code와 Data 영역만 덮어 씌워진다. 이미 만들어진 PCB, 메모리영역을 사용하기 때문에, 기존의 데이터가 사라진다는 점을 제외하면, 새로운 프로세스를 사용하기에 fork보다 편리합니다.