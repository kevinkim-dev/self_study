# 자료구조



### 1. 해시테이블을 구현하는 방법에 대해 설명해주세요.

- 해시 테이블에는 해시 충돌이 되도록 적게 일어나게 하는 해시 함수와, 해시 충돌 시 처리 로직이 필요합니다. 해시 충돌이 일어나지 않게 하는 hash function 알고리즘으로는 value를 테이블 크기로 나눈 나머지를 hash로 쓰는 Division Method, value를 ASCII 코드로 바꾸고 합한 데이터를 테이블의 주소로 사용하는 Digit Folding, value와 0~1사이 상수를 곱한 소수부분에 2의 상수승을 곱한 값을 hash로 사용하는 Multiplication Method, 그리고 다양한 해시함수에서 무작위 함수를 선택해서 사용하는 Universal method 가 있습니다. 해시 충돌이 일어 났을 때 처리 로직도 필요한데, 충돌한 값을 같은 index에 linkedlist로 연결한 seperate Chaning기법, 그리고 일정 기준에 따라 다음 주소로 이동해서 어떻게든 다른 주소에 저장하는 Open Addressing이 있습니다. seperate chaning에는 별다른 로직이 필요없지만, hash function에 따라 검색 속도가 O(N) 까지 느려질 수 있습니다. Open Addressing은 table 크기보다 적은 수의 data가 들어오기 전까지는 O(1)로 검색할 수 있지만, new Address를 찾기위한 과정이 오래걸릴 수 있습니다.





### 2. Array와 LinkedList의 차이점을 시간 복잡도와 연관지어 설명해주세요.

- Array와 LinkedList는 저장되는 물리적 주소의 연속성의 주된 차이점이 있습니다.
- Array는 요소들이 연속된 주소에 저장되기 때문에 Index값으로 Random Access를 지원합니다. 반면 LinkedList는 연속되지 않은 주소에 저장되기 때문에, 각 node가 value와 함께 다음 node의 위치를 가리키는 주소를 함께 가지고 있으며 이러한 특성 때문에 순서대로만 탐색할 수 있는 Sequential Access를 지원합니다.
- 조회
  - Array는 Random Access로 원하는 Index를 통해 한번에 찾을 수 있기 때문에 O(1)입니다.
  - Linked List는 Index가 없어 Sequential Access로 search하듯이 찾아야 하기 때문에 O(N)입니다.
- search
  - Array는 index 0~N-1까지 모두 찾아야하므로 최악의 경우 O(N)입니다.
  - Linked List는 조회와 같은 로직으로 O(N)입니다,
- Insert(맨 앞에)
  - Array는 모든 원소를 오른쪽으로 미는데 O(N), 삽입에 O(1)이므로 O(N)입니다.
  - Linked List는 새로운 노드를 생성하고, 노드가 LinkedList의 원래 첫번째 노드의 주소를 가리키게 하기만 하면 되므로 O(1)입니다.
- Insert(맨 뒤에)
  - Array는 맨 뒤에 삽입만 하므로 O(1)입니다.
  - Linked List는 sequential Access로 마지막 노드까지 찾아가는데 O(N), 거기서 노드를 삽입하는데 O(1)이므로 O(N)입니다.
- delete
  - Insert와 동일합니다.
- 메모리 할당
  - Array는 Compile Time에 할당하는 Static Memory Allocation이 이루어집니다. 즉 첫 할당에 충분한 길이의 Array를 선언해야하며, 해당 길이가 넘어가면 담을 수 없다는 단점이 있습니다. 이 때 메모리 할당은 Stack에 이루어집니다.
  - Linked List는 runtime에 필요할때마다 할당하는 Dynamic Memory Allocation이 이루어집니다. node가 추가 될 때마다 추가되는 node의 memory 할당을 요구하는 system call이 발생하며 길이에 제한이 없다는 장점이 있지만 잦은 system call로 시간이 지연될 수 있습니다. 메모리 할당은 heap에서 이루어집니다
- 결론
  - 시간
    - Array는 메모리 할당이 한번에 이루어져 추후 시간 지연이없고, 조회의 면에서 LinkedList보다 빠른 장점이 있습니다. 따라서 상대적으로 조회와 검색에 유리하고 삽입과 삭제에 불리합니다
    - Linked List는 길이 확장이 가능하지만 index가 없어서 삽입과 수정의 작업에서 유리하지만, 조회와 검색에서는 상대적으로 불리합니다. 다만 메모리의 할당과, 해제에서 System call이 발생해서 느려질 수 있습니다.
  - 공간
    - Array를 한번에 충분히 큰 크기로 잡는다면 시간적으로 Linked List에 비해 유리하지만, 내부 단편화가 이루어질 수 있습니다. 예를 들어 Array의 길이를 100만으로 잡았는데 실제로 들어간 데이터는 5개라고 했을 때, 조회, 탐색, 삽입, 삭제 모든 면에서 시간적으로 LinkedList에 비해 밀리지 않지만 남은 99만9995개의 공간은 Array를 해제하기 전까지는 내부 단편화가 일어나 낭비됩니다.
    - LinkedList는 공간이 필요할때, 필요하지 않을때마다 공간이 할당되거나 해제되어 메모리 사용 시 낭비가 일어나지 않습니다.





### 3. Stack으로 Queue, Queue로 Stack 구현

- Stack 2개로 Queue 구현
  - Stack에 원소를 모두 push한 경우 가장 깊숙한 원소가 출력되어야 dequeue를 구현할 수 있는데, 여분의 stack에 모든 내용을 pop해서 차례로 푸시한 후, 원래 stack이 비었을 때, 여분의 stack에서 pop을 한번 해주면 가장 깊숙히 있던 원소를 dequeue할 수 있다.
  - 여분의 stack에 원소가 남아있더라도, 다시 enqueue가 발생하면 원래 stack에 push한다. pop이 발생하면, 여분의 stack에 남는 원소가 없을 때까지 여분의 stack에서 pop하고 여분의 스택이 비었을때 pop이 들어오면 다시 원래 stack의 모든 원소를 pop해서 여분의 stack에 넣고 pop하는 과정을 반복한다.

- Queue 2개로 Stack 구현
  - Queue에 원소를 모두 그냥 enqueue한 경우 dequeue를 하다가 마지막원소임을 깨닫고 pop해주는 방법이 존재하지 않습니다. 따라서 애초에 dequeue == pop 이 되도록 구현을 해주어야 합니다.
  - 두 개의 queue 중 push는 비어있는 queue에 진행합니다. 그리고 반대 queue의 모든 원소를 dequeue해서 방금 push한 enqueue해줍니다.
  - 이렇게되면 모든 dequeue연산은 pop과 같아집니다.

